<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapleQuest RPG</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', sans-serif;
        }
        .game-container {
            position: relative;
        }
        canvas {
            border: 4px solid #4a4a6a;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(100, 100, 255, 0.3);
        }
        .ui-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        .stat-bar {
            width: 200px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin: 5px 0;
            overflow: hidden;
            border: 2px solid #555;
        }
        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            transition: width 0.3s;
        }
        .mp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4444ff, #6666ff);
            transition: width 0.3s;
        }
        .exp-fill {
            height: 100%;
            background: linear-gradient(90deg, #44ff44, #66ff66);
            transition: width 0.3s;
        }
        .controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #aaa;
            font-size: 12px;
        }
        .level-up {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffff00;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 20px #ffff00;
            animation: levelUp 2s ease-out forwards;
            pointer-events: none;
            display: none;
        }
        @keyframes levelUp {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -100%) scale(1); }
        }

        /* ÏßÅÏóÖ ÏÑ†ÌÉù ÌôîÎ©¥ */
        .job-select {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            border-radius: 8px;
        }
        .job-select h1 {
            color: #ffcc00;
            font-size: 36px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #ffcc00;
        }
        .job-select p {
            color: #aaa;
            margin-bottom: 30px;
        }
        .job-cards {
            display: flex;
            gap: 20px;
        }
        .job-card {
            width: 200px;
            padding: 20px;
            background: linear-gradient(135deg, #2a2a4a, #1a1a3a);
            border: 3px solid #4a4a6a;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        .job-card:hover {
            transform: translateY(-10px);
            border-color: #ffcc00;
            box-shadow: 0 10px 30px rgba(255, 204, 0, 0.3);
        }
        .job-card h2 {
            color: #fff;
            margin-bottom: 10px;
        }
        .job-card .job-icon {
            font-size: 60px;
            margin: 15px 0;
        }
        .job-card .job-stats {
            color: #aaa;
            font-size: 12px;
            text-align: left;
            margin-top: 15px;
        }
        .job-card .job-stats div {
            margin: 5px 0;
        }
        .job-card.warrior { border-top: 4px solid #ff6644; }
        .job-card.thief { border-top: 4px solid #aa44ff; }
        .job-card.archer { border-top: 4px solid #44ff66; }

        .job-card.warrior:hover { border-color: #ff6644; box-shadow: 0 10px 30px rgba(255, 102, 68, 0.3); }
        .job-card.thief:hover { border-color: #aa44ff; box-shadow: 0 10px 30px rgba(170, 68, 255, 0.3); }
        .job-card.archer:hover { border-color: #44ff66; box-shadow: 0 10px 30px rgba(68, 255, 102, 0.3); }

        /* Ïä§ÌÇ¨ UI */
        .skill-bar {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        .skill-slot {
            width: 50px;
            height: 50px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #555;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 10px;
            position: relative;
        }
        .skill-slot .key {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            padding: 1px 5px;
            border-radius: 3px;
            font-size: 9px;
        }
        .skill-slot .cooldown {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            font-weight: bold;
            border-radius: 6px;
        }
        .skill-slot.ready {
            border-color: #44ff44;
            box-shadow: 0 0 10px rgba(68, 255, 68, 0.5);
        }

        /* Î≤ÑÌîÑ ÌëúÏãú */
        .buff-bar {
            position: absolute;
            top: 130px;
            left: 10px;
            display: flex;
            gap: 5px;
        }
        .buff-icon {
            width: 30px;
            height: 30px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #ffcc00;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="1000" height="600"></canvas>

        <!-- ÏßÅÏóÖ ÏÑ†ÌÉù ÌôîÎ©¥ -->
        <div class="job-select" id="jobSelect">
            <h1>ÏßÅÏóÖÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</h1>
            <p>Í∞Å ÏßÅÏóÖÏùÄ Í≥†Ïú†Ìïú Ïä§ÌÉØÍ≥º Ïä§ÌÇ¨ÏùÑ Í∞ÄÏßÄÍ≥† ÏûàÏäµÎãàÎã§</p>
            <div class="job-cards">
                <div class="job-card warrior" onclick="selectJob('warrior')">
                    <h2 style="color: #ff6644">Ï†ÑÏÇ¨</h2>
                    <div class="job-icon">‚öîÔ∏è</div>
                    <div class="job-stats">
                        <div>‚ù§Ô∏è HP: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ</div>
                        <div>‚ö° ÏÜçÎèÑ: ‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ</div>
                        <div>üí™ Í≥µÍ≤©Î†•: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ</div>
                        <div style="color: #ff6644; margin-top: 10px;">
                            <b>Ïä§ÌÇ¨:</b><br>
                            [Z] ÌååÏõå Ïä§Ìä∏ÎùºÏù¥ÌÅ¨<br>
                            [X] Ïä¨ÎûòÏãú Î∏îÎûòÏä§Ìä∏<br>
                            [C] Î†àÏù¥ÏßÄ (Î≤ÑÌîÑ)
                        </div>
                    </div>
                </div>
                <div class="job-card thief" onclick="selectJob('thief')">
                    <h2 style="color: #aa44ff">ÎèÑÏ†Å</h2>
                    <div class="job-icon">üó°Ô∏è</div>
                    <div class="job-stats">
                        <div>‚ù§Ô∏è HP: ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ</div>
                        <div>‚ö° ÏÜçÎèÑ: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ</div>
                        <div>üí™ Í≥µÍ≤©Î†•: ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ</div>
                        <div style="color: #aa44ff; margin-top: 10px;">
                            <b>Ïä§ÌÇ¨:</b><br>
                            [Z] ÎçîÎ∏î Ïä§ÌÉ≠<br>
                            [X] Ïñ¥ÏåîÏãúÎÑ§Ïù¥Ìä∏<br>
                            [C] Ìó§Ïù¥Ïä§Ìä∏ (Î≤ÑÌîÑ)
                        </div>
                    </div>
                </div>
                <div class="job-card archer" onclick="selectJob('archer')">
                    <h2 style="color: #44ff66">Í∂ÅÏàò</h2>
                    <div class="job-icon">üèπ</div>
                    <div class="job-stats">
                        <div>‚ù§Ô∏è HP: ‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ</div>
                        <div>‚ö° ÏÜçÎèÑ: ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ</div>
                        <div>üí™ Í≥µÍ≤©Î†•: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ</div>
                        <div style="color: #44ff66; margin-top: 10px;">
                            <b>Ïä§ÌÇ¨:</b><br>
                            [Z] ÎçîÎ∏î ÏÉ∑<br>
                            [X] Ïï†Î°úÏö∞ Î†àÏù∏<br>
                            [C] ÏÜåÏö∏ Ïï†Î°úÏö∞ (Î≤ÑÌîÑ)
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="ui-overlay" id="gameUI" style="display: none;">
            <div><span id="jobIcon">‚öîÔ∏è</span> Lv. <span id="level">1</span> <span id="jobName">Ï†ÑÏÇ¨</span></div>
            <div class="stat-bar">
                <div class="hp-fill" id="hpBar" style="width: 100%"></div>
            </div>
            <div style="font-size: 12px">HP: <span id="hpText">100/100</span></div>
            <div class="stat-bar">
                <div class="mp-fill" id="mpBar" style="width: 100%"></div>
            </div>
            <div style="font-size: 12px">MP: <span id="mpText">50/50</span></div>
            <div class="stat-bar">
                <div class="exp-fill" id="expBar" style="width: 0%"></div>
            </div>
            <div style="font-size: 12px">EXP: <span id="expText">0/100</span></div>
            <div style="margin-top: 10px">Í≥µÍ≤©Î†•: <span id="attack">10</span></div>
            <div>ÌÅ¨Î¶¨Ìã∞Ïª¨: <span id="crit">10</span>%</div>
            <div>Ï≤òÏπò: <span id="kills">0</span></div>
        </div>

        <div class="buff-bar" id="buffBar"></div>

        <div class="skill-bar" id="skillBar"></div>

        <div class="controls" id="controlsUI" style="display: none;">
            [‚Üê‚Üí] Ïù¥Îèô | [‚Üë/Space] Ï†êÌîÑ | [Z][X][C] Ïä§ÌÇ¨
        </div>
        <div class="level-up" id="levelUpText">LEVEL UP!</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ÏßÅÏóÖ Ï†ïÏùò
        const JOBS = {
            warrior: {
                name: 'Ï†ÑÏÇ¨',
                icon: '‚öîÔ∏è',
                color: '#ff6644',
                baseHp: 150,
                baseMp: 30,
                baseAttack: 15,
                speed: 4,
                jumpPower: -13,
                critChance: 10,
                hpPerLevel: 30,
                mpPerLevel: 5,
                attackPerLevel: 7,
                skills: [
                    { name: 'ÌååÏõå Ïä§Ìä∏ÎùºÏù¥ÌÅ¨', key: 'Z', mp: 5, cooldown: 30, damage: 2.5, type: 'melee', icon: 'üí•' },
                    { name: 'Ïä¨ÎûòÏãú Î∏îÎûòÏä§Ìä∏', key: 'X', mp: 10, cooldown: 90, damage: 1.5, type: 'aoe', range: 150, icon: 'üåÄ' },
                    { name: 'Î†àÏù¥ÏßÄ', key: 'C', mp: 15, cooldown: 600, duration: 600, buff: 'rage', attackBonus: 1.5, icon: 'üò§' }
                ]
            },
            thief: {
                name: 'ÎèÑÏ†Å',
                icon: 'üó°Ô∏è',
                color: '#aa44ff',
                baseHp: 100,
                baseMp: 50,
                baseAttack: 12,
                speed: 7,
                jumpPower: -14,
                critChance: 25,
                hpPerLevel: 20,
                mpPerLevel: 8,
                attackPerLevel: 5,
                skills: [
                    { name: 'ÎçîÎ∏î Ïä§ÌÉ≠', key: 'Z', mp: 4, cooldown: 20, damage: 1.8, hits: 2, type: 'melee', icon: '‚ö°' },
                    { name: 'Ïñ¥ÏåîÏãúÎÑ§Ïù¥Ìä∏', key: 'X', mp: 12, cooldown: 120, damage: 4.0, type: 'melee', backstab: true, icon: 'üíÄ' },
                    { name: 'Ìó§Ïù¥Ïä§Ìä∏', key: 'C', mp: 10, cooldown: 480, duration: 600, buff: 'haste', speedBonus: 1.5, icon: 'üí®' }
                ]
            },
            archer: {
                name: 'Í∂ÅÏàò',
                icon: 'üèπ',
                color: '#44ff66',
                baseHp: 80,
                baseMp: 40,
                baseAttack: 18,
                speed: 5,
                jumpPower: -13,
                critChance: 20,
                hpPerLevel: 15,
                mpPerLevel: 7,
                attackPerLevel: 8,
                skills: [
                    { name: 'ÎçîÎ∏î ÏÉ∑', key: 'Z', mp: 3, cooldown: 15, damage: 1.5, arrows: 2, type: 'ranged', icon: '‚ûπ' },
                    { name: 'Ïï†Î°úÏö∞ Î†àÏù∏', key: 'X', mp: 15, cooldown: 150, damage: 1.0, type: 'rain', icon: 'üåßÔ∏è' },
                    { name: 'ÏÜåÏö∏ Ïï†Î°úÏö∞', key: 'C', mp: 8, cooldown: 420, duration: 600, buff: 'soul', piercing: true, icon: '‚ú®' }
                ]
            }
        };

        // Í≤åÏûÑ ÏÉÅÌÉú
        const game = {
            started: false,
            gravity: 0.6,
            groundY: 500,
            platforms: [
                { x: 0, y: 500, width: 1000, height: 100 },
                { x: 150, y: 400, width: 150, height: 20 },
                { x: 420, y: 350, width: 160, height: 20 },
                { x: 700, y: 400, width: 150, height: 20 },
                { x: 50, y: 280, width: 120, height: 20 },
                { x: 550, y: 250, width: 120, height: 20 },
                { x: 820, y: 280, width: 120, height: 20 },
            ],
            monsters: [],
            particles: [],
            damageTexts: [],
            projectiles: [],
            keys: {},
            lastMonsterSpawn: 0,
            monsterSpawnInterval: 2500,
        };

        // ÌîåÎ†àÏù¥Ïñ¥
        const player = {
            x: 100,
            y: 400,
            width: 40,
            height: 60,
            vx: 0,
            vy: 0,
            speed: 5,
            jumpPower: -14,
            isJumping: false,
            direction: 1,
            isAttacking: false,
            attackFrame: 0,
            hp: 100,
            maxHp: 100,
            mp: 50,
            maxMp: 50,
            exp: 0,
            expToLevel: 100,
            level: 1,
            attack: 10,
            critChance: 10,
            kills: 0,
            invincible: 0,
            job: null,
            skillCooldowns: [0, 0, 0],
            buffs: {},
        };

        // ÏßÅÏóÖ ÏÑ†ÌÉù
        function selectJob(jobId) {
            const job = JOBS[jobId];
            player.job = jobId;
            player.maxHp = job.baseHp;
            player.hp = job.baseHp;
            player.maxMp = job.baseMp;
            player.mp = job.baseMp;
            player.attack = job.baseAttack;
            player.speed = job.speed;
            player.jumpPower = job.jumpPower;
            player.critChance = job.critChance;

            document.getElementById('jobSelect').style.display = 'none';
            document.getElementById('gameUI').style.display = 'block';
            document.getElementById('controlsUI').style.display = 'block';
            document.getElementById('jobName').textContent = job.name;
            document.getElementById('jobIcon').textContent = job.icon;

            createSkillBar();
            updateUI();
            game.started = true;
        }

        // Ïä§ÌÇ¨Î∞î ÏÉùÏÑ±
        function createSkillBar() {
            const skillBar = document.getElementById('skillBar');
            const job = JOBS[player.job];
            skillBar.innerHTML = '';

            job.skills.forEach((skill, i) => {
                const slot = document.createElement('div');
                slot.className = 'skill-slot ready';
                slot.id = `skill${i}`;
                slot.innerHTML = `
                    <div class="key">${skill.key}</div>
                    <div style="font-size: 20px">${skill.icon}</div>
                    <div style="font-size: 9px">${skill.name.substring(0, 4)}</div>
                `;
                skillBar.appendChild(slot);
            });
        }

        // Ïä§ÌÇ¨Î∞î ÏóÖÎç∞Ïù¥Ìä∏
        function updateSkillBar() {
            const job = JOBS[player.job];
            job.skills.forEach((skill, i) => {
                const slot = document.getElementById(`skill${i}`);
                const cooldown = player.skillCooldowns[i];

                if (cooldown > 0) {
                    slot.className = 'skill-slot';
                    const existingCd = slot.querySelector('.cooldown');
                    if (existingCd) {
                        existingCd.textContent = Math.ceil(cooldown / 60);
                    } else {
                        const cdDiv = document.createElement('div');
                        cdDiv.className = 'cooldown';
                        cdDiv.textContent = Math.ceil(cooldown / 60);
                        slot.appendChild(cdDiv);
                    }
                } else {
                    slot.className = 'skill-slot ready';
                    const existingCd = slot.querySelector('.cooldown');
                    if (existingCd) existingCd.remove();
                }
            });
        }

        // Î≤ÑÌîÑÎ∞î ÏóÖÎç∞Ïù¥Ìä∏
        function updateBuffBar() {
            const buffBar = document.getElementById('buffBar');
            buffBar.innerHTML = '';

            for (const [buffName, buffData] of Object.entries(player.buffs)) {
                if (buffData.duration > 0) {
                    const buffIcon = document.createElement('div');
                    buffIcon.className = 'buff-icon';
                    buffIcon.innerHTML = buffData.icon;
                    buffIcon.title = `${buffName}: ${Math.ceil(buffData.duration / 60)}s`;
                    buffBar.appendChild(buffIcon);
                }
            }
        }

        // Î™¨Ïä§ÌÑ∞ ÌÅ¥ÎûòÏä§
        class Monster {
            constructor(x, y, type = 'slime') {
                this.x = x;
                this.y = y;
                this.type = type;

                const monsterTypes = {
                    slime: { width: 50, height: 40, hp: 30 + player.level * 10, damage: 8 + player.level * 2, exp: 25, color: '#44dd44' },
                    mushroom: { width: 55, height: 50, hp: 50 + player.level * 15, damage: 12 + player.level * 3, exp: 40, color: '#dd4444' },
                    stump: { width: 60, height: 55, hp: 80 + player.level * 20, damage: 15 + player.level * 4, exp: 60, color: '#8B4513' }
                };

                const mt = monsterTypes[type];
                this.width = mt.width;
                this.height = mt.height;
                this.hp = mt.hp;
                this.maxHp = mt.hp;
                this.damage = mt.damage;
                this.exp = mt.exp;
                this.color = mt.color;

                this.vx = (Math.random() - 0.5) * 2;
                this.vy = 0;
                this.isDead = false;
                this.deathTimer = 0;
                this.animFrame = 0;
            }

            update() {
                if (this.isDead) {
                    this.deathTimer++;
                    return this.deathTimer > 30;
                }

                this.animFrame += 0.1;

                if (Math.random() < 0.02) {
                    this.vx = (Math.random() - 0.5) * 3;
                }

                const dx = player.x - this.x;
                if (Math.abs(dx) < 300) {
                    this.vx += Math.sign(dx) * 0.1;
                }
                this.vx = Math.max(-2, Math.min(2, this.vx));

                this.x += this.vx;
                this.vy += game.gravity;
                this.y += this.vy;

                for (const p of game.platforms) {
                    if (this.y + this.height > p.y &&
                        this.y + this.height < p.y + p.height + 10 &&
                        this.x + this.width > p.x &&
                        this.x < p.x + p.width &&
                        this.vy >= 0) {
                        this.y = p.y - this.height;
                        this.vy = 0;
                    }
                }

                if (this.x < 0) { this.x = 0; this.vx *= -1; }
                if (this.x + this.width > canvas.width) {
                    this.x = canvas.width - this.width;
                    this.vx *= -1;
                }

                if (player.invincible <= 0 && this.checkCollision(player)) {
                    player.hp -= this.damage;
                    player.invincible = 60;
                    player.vx = Math.sign(player.x - this.x) * 8;
                    player.vy = -5;
                    createDamageText(player.x, player.y, this.damage, '#ff4444');
                    updateUI();
                }

                return false;
            }

            checkCollision(obj) {
                return this.x < obj.x + obj.width &&
                       this.x + this.width > obj.x &&
                       this.y < obj.y + obj.height &&
                       this.y + this.height > obj.y;
            }

            draw() {
                ctx.save();

                if (this.isDead) {
                    ctx.globalAlpha = 1 - this.deathTimer / 30;
                }

                const bounce = Math.sin(this.animFrame) * 3;

                if (this.type === 'slime') {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.width/2, this.y + this.height - 15 + bounce, this.width/2 - 5, this.height/2 - 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.width/2 - 8, this.y + this.height - 25 + bounce, 8, 6, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'mushroom') {
                    ctx.fillStyle = '#DEB887';
                    ctx.fillRect(this.x + 18, this.y + 28 + bounce, 20, 22);
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.width/2, this.y + 22 + bounce, 28, 22, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(this.x + 18, this.y + 18 + bounce, 6, 0, Math.PI * 2);
                    ctx.arc(this.x + 38, this.y + 20 + bounce, 5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'stump') {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x + 10, this.y + 15 + bounce, 40, 40);
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.arc(this.x + 30, this.y + 35 + bounce, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#4a3520';
                    ctx.beginPath();
                    ctx.arc(this.x + 30, this.y + 35 + bounce, 6, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(this.x + this.width/2 - 8, this.y + this.height/2 + bounce, 3, 0, Math.PI * 2);
                ctx.arc(this.x + this.width/2 + 8, this.y + this.height/2 + bounce, 3, 0, Math.PI * 2);
                ctx.fill();

                if (!this.isDead) {
                    const hpWidth = (this.hp / this.maxHp) * this.width;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x, this.y - 10, this.width, 5);
                    ctx.fillStyle = '#ff4444';
                    ctx.fillRect(this.x, this.y - 10, hpWidth, 5);
                }

                ctx.restore();
            }

            takeDamage(dmg, isCrit = false, isBackstab = false) {
                let finalDmg = dmg;
                if (isCrit) finalDmg *= 1.5;
                if (isBackstab) finalDmg *= 2;
                finalDmg = Math.floor(finalDmg);

                this.hp -= finalDmg;
                const color = isCrit ? '#ffaa00' : (isBackstab ? '#ff00ff' : '#ffff00');
                createDamageText(this.x + this.width/2, this.y, finalDmg + (isCrit ? '!' : ''), color);
                createParticles(this.x + this.width/2, this.y + this.height/2, this.color);

                if (this.hp <= 0) {
                    this.isDead = true;
                    player.exp += this.exp;
                    player.kills++;
                    checkLevelUp();
                    updateUI();
                }
            }
        }

        // Ìà¨ÏÇ¨Ï≤¥ ÌÅ¥ÎûòÏä§
        class Projectile {
            constructor(x, y, direction, damage, type = 'arrow', piercing = false) {
                this.x = x;
                this.y = y;
                this.direction = direction;
                this.speed = 12;
                this.damage = damage;
                this.type = type;
                this.piercing = piercing;
                this.hitMonsters = new Set();
                this.life = 100;
            }

            update() {
                this.x += this.speed * this.direction;
                this.life--;

                if (this.x < 0 || this.x > canvas.width) return true;

                for (const monster of game.monsters) {
                    if (!monster.isDead && !this.hitMonsters.has(monster) &&
                        this.x > monster.x && this.x < monster.x + monster.width &&
                        this.y > monster.y && this.y < monster.y + monster.height) {

                        const isCrit = Math.random() * 100 < player.critChance;
                        monster.takeDamage(this.damage, isCrit);
                        this.hitMonsters.add(monster);

                        if (!this.piercing) return true;
                    }
                }

                return this.life <= 0;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                if (this.type === 'arrow') {
                    ctx.fillStyle = player.buffs.soul ? '#00ffff' : '#8B4513';
                    ctx.rotate(this.direction === 1 ? 0 : Math.PI);
                    ctx.beginPath();
                    ctx.moveTo(15, 0);
                    ctx.lineTo(-10, -3);
                    ctx.lineTo(-10, 3);
                    ctx.closePath();
                    ctx.fill();

                    if (player.buffs.soul && player.buffs.soul.duration > 0) {
                        ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
                        ctx.beginPath();
                        ctx.arc(0, 0, 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.restore();
            }
        }

        // Ïä§ÌÇ¨ ÏÇ¨Ïö©
        function useSkill(skillIndex) {
            if (!game.started || player.skillCooldowns[skillIndex] > 0) return;

            const job = JOBS[player.job];
            const skill = job.skills[skillIndex];

            if (player.mp < skill.mp) return;

            player.mp -= skill.mp;
            player.skillCooldowns[skillIndex] = skill.cooldown;
            player.isAttacking = true;
            setTimeout(() => player.isAttacking = false, 200);

            const attackMultiplier = player.buffs.rage ? player.buffs.rage.attackBonus : 1;
            const baseDamage = player.attack * skill.damage * attackMultiplier;

            switch (skill.type) {
                case 'melee':
                    performMeleeAttack(baseDamage, skill);
                    break;
                case 'aoe':
                    performAoeAttack(baseDamage, skill);
                    break;
                case 'ranged':
                    performRangedAttack(baseDamage, skill);
                    break;
                case 'rain':
                    performRainAttack(baseDamage, skill);
                    break;
            }

            if (skill.buff) {
                player.buffs[skill.buff] = {
                    duration: skill.duration,
                    icon: skill.icon,
                    ...skill
                };
            }

            updateUI();
        }

        function performMeleeAttack(damage, skill) {
            const attackBox = {
                x: player.direction === 1 ? player.x + player.width : player.x - 80,
                y: player.y - 10,
                width: 80,
                height: player.height + 20
            };

            const hits = skill.hits || 1;

            for (let h = 0; h < hits; h++) {
                setTimeout(() => {
                    for (const monster of game.monsters) {
                        if (!monster.isDead &&
                            attackBox.x < monster.x + monster.width &&
                            attackBox.x + attackBox.width > monster.x &&
                            attackBox.y < monster.y + monster.height &&
                            attackBox.y + attackBox.height > monster.y) {

                            const isCrit = Math.random() * 100 < player.critChance;
                            const isBackstab = skill.backstab &&
                                ((player.direction === 1 && monster.vx > 0) ||
                                 (player.direction === -1 && monster.vx < 0));

                            monster.takeDamage(damage, isCrit, isBackstab);
                        }
                    }
                    createMeleeEffect(attackBox);
                }, h * 100);
            }
        }

        function performAoeAttack(damage, skill) {
            const range = skill.range || 150;

            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                game.particles.push({
                    x: player.x + player.width/2,
                    y: player.y + player.height/2,
                    vx: Math.cos(angle) * 8,
                    vy: Math.sin(angle) * 8,
                    life: 20,
                    color: JOBS[player.job].color,
                    size: 6
                });
            }

            for (const monster of game.monsters) {
                if (!monster.isDead) {
                    const dx = monster.x + monster.width/2 - (player.x + player.width/2);
                    const dy = monster.y + monster.height/2 - (player.y + player.height/2);
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist < range) {
                        const isCrit = Math.random() * 100 < player.critChance;
                        monster.takeDamage(damage, isCrit);
                    }
                }
            }
        }

        function performRangedAttack(damage, skill) {
            const arrows = skill.arrows || 1;
            const piercing = player.buffs.soul && player.buffs.soul.duration > 0;

            for (let i = 0; i < arrows; i++) {
                setTimeout(() => {
                    const offsetY = (i - (arrows-1)/2) * 15;
                    game.projectiles.push(new Projectile(
                        player.x + (player.direction === 1 ? player.width : 0),
                        player.y + player.height/2 + offsetY,
                        player.direction,
                        damage,
                        'arrow',
                        piercing
                    ));
                }, i * 80);
            }
        }

        function performRainAttack(damage, skill) {
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const x = Math.random() * canvas.width;
                    game.particles.push({
                        x: x,
                        y: 0,
                        vx: 0,
                        vy: 15,
                        life: 50,
                        color: '#44ff66',
                        size: 4,
                        isArrow: true
                    });

                    setTimeout(() => {
                        for (const monster of game.monsters) {
                            if (!monster.isDead && Math.abs(monster.x + monster.width/2 - x) < 30) {
                                const isCrit = Math.random() * 100 < player.critChance;
                                monster.takeDamage(damage, isCrit);
                            }
                        }
                    }, 300);
                }, i * 50);
            }
        }

        function createMeleeEffect(box) {
            for (let i = 0; i < 15; i++) {
                game.particles.push({
                    x: box.x + Math.random() * box.width,
                    y: box.y + Math.random() * box.height,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 15,
                    color: JOBS[player.job].color,
                    size: Math.random() * 6 + 2
                });
            }
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < 10; i++) {
                game.particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8 - 3,
                    life: 30,
                    color,
                    size: Math.random() * 5 + 2
                });
            }
        }

        function createDamageText(x, y, damage, color) {
            game.damageTexts.push({
                x, y,
                damage,
                color,
                life: 60,
                vy: -2
            });
        }

        function checkLevelUp() {
            while (player.exp >= player.expToLevel) {
                player.exp -= player.expToLevel;
                player.level++;

                const job = JOBS[player.job];
                player.maxHp += job.hpPerLevel;
                player.hp = player.maxHp;
                player.maxMp += job.mpPerLevel;
                player.mp = player.maxMp;
                player.attack += job.attackPerLevel;
                player.expToLevel = Math.floor(player.expToLevel * 1.5);

                const levelUpText = document.getElementById('levelUpText');
                levelUpText.style.display = 'block';
                levelUpText.style.animation = 'none';
                levelUpText.offsetHeight;
                levelUpText.style.animation = 'levelUp 2s ease-out forwards';
                setTimeout(() => levelUpText.style.display = 'none', 2000);

                for (let i = 0; i < 50; i++) {
                    game.particles.push({
                        x: player.x + player.width/2 + (Math.random() - 0.5) * 100,
                        y: player.y + player.height/2 + (Math.random() - 0.5) * 100,
                        vx: (Math.random() - 0.5) * 4,
                        vy: -Math.random() * 5,
                        life: 60,
                        color: '#ffff00',
                        size: Math.random() * 6 + 3
                    });
                }
            }
        }

        function updateUI() {
            if (!game.started) return;

            document.getElementById('level').textContent = player.level;
            document.getElementById('hpBar').style.width = (player.hp / player.maxHp * 100) + '%';
            document.getElementById('hpText').textContent = `${Math.max(0, Math.floor(player.hp))}/${player.maxHp}`;
            document.getElementById('mpBar').style.width = (player.mp / player.maxMp * 100) + '%';
            document.getElementById('mpText').textContent = `${Math.max(0, Math.floor(player.mp))}/${player.maxMp}`;
            document.getElementById('expBar').style.width = (player.exp / player.expToLevel * 100) + '%';
            document.getElementById('expText').textContent = `${player.exp}/${player.expToLevel}`;
            document.getElementById('attack').textContent = Math.floor(player.attack * (player.buffs.rage ? player.buffs.rage.attackBonus : 1));
            document.getElementById('crit').textContent = player.critChance;
            document.getElementById('kills').textContent = player.kills;
        }

        function spawnMonster() {
            const now = Date.now();
            if (now - game.lastMonsterSpawn > game.monsterSpawnInterval && game.monsters.length < 10) {
                const x = Math.random() * (canvas.width - 100) + 50;
                const rand = Math.random();
                let type = 'slime';
                if (rand > 0.7 && player.level >= 3) type = 'stump';
                else if (rand > 0.4) type = 'mushroom';

                game.monsters.push(new Monster(x, 50, type));
                game.lastMonsterSpawn = now;
                game.monsterSpawnInterval = Math.max(1000, 2500 - player.level * 100);
            }
        }

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a1a3e');
            gradient.addColorStop(0.5, '#2a2a5e');
            gradient.addColorStop(1, '#3a3a7e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 50; i++) {
                const x = (i * 73) % canvas.width;
                const y = (i * 37) % (canvas.height - 200);
                const size = (i % 3) + 1;
                ctx.globalAlpha = 0.3 + Math.sin(Date.now() / 1000 + i) * 0.3;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            for (const p of game.platforms) {
                const platGradient = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.height);
                platGradient.addColorStop(0, '#5a8a5a');
                platGradient.addColorStop(1, '#3a6a3a');
                ctx.fillStyle = platGradient;
                ctx.fillRect(p.x, p.y, p.width, p.height);

                ctx.fillStyle = '#7aba7a';
                ctx.fillRect(p.x, p.y, p.width, 5);

                ctx.fillStyle = '#4a9a4a';
                for (let i = 0; i < p.width; i += 10) {
                    ctx.beginPath();
                    ctx.moveTo(p.x + i, p.y);
                    ctx.lineTo(p.x + i + 5, p.y - 8);
                    ctx.lineTo(p.x + i + 10, p.y);
                    ctx.fill();
                }
            }
        }

        function drawPlayer() {
            ctx.save();

            if (player.invincible > 0 && Math.floor(player.invincible / 5) % 2 === 0) {
                ctx.globalAlpha = 0.5;
            }

            const px = player.x;
            const py = player.y;
            const dir = player.direction;
            const job = JOBS[player.job];

            ctx.translate(px + player.width/2, py);
            ctx.scale(dir, 1);
            ctx.translate(-(px + player.width/2), -py);

            // Î≤ÑÌîÑ Ïù¥ÌéôÌä∏
            if (player.buffs.rage && player.buffs.rage.duration > 0) {
                ctx.fillStyle = 'rgba(255, 100, 50, 0.3)';
                ctx.beginPath();
                ctx.arc(px + player.width/2, py + player.height/2, 40, 0, Math.PI * 2);
                ctx.fill();
            }
            if (player.buffs.haste && player.buffs.haste.duration > 0) {
                ctx.fillStyle = 'rgba(170, 68, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(px + player.width/2, py + player.height/2, 35, 0, Math.PI * 2);
                ctx.fill();
            }
            if (player.buffs.soul && player.buffs.soul.duration > 0) {
                ctx.fillStyle = 'rgba(68, 255, 102, 0.3)';
                ctx.beginPath();
                ctx.arc(px + player.width/2, py + player.height/2, 35, 0, Math.PI * 2);
                ctx.fill();
            }

            // ÏßÅÏóÖÎ≥Ñ ÏÉâÏÉÅ
            const bodyColor = job ? job.color : '#4488ff';

            // Î™∏ÌÜµ
            ctx.fillStyle = bodyColor;
            ctx.fillRect(px + 8, py + 20, 24, 30);

            // Î®∏Î¶¨
            ctx.fillStyle = '#ffcc99';
            ctx.beginPath();
            ctx.arc(px + player.width/2, py + 15, 15, 0, Math.PI * 2);
            ctx.fill();

            // Î®∏Î¶¨Ïπ¥ÎùΩ (ÏßÅÏóÖÎ≥Ñ)
            if (player.job === 'warrior') {
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(px + player.width/2, py + 8, 14, Math.PI, Math.PI * 2);
                ctx.fill();
            } else if (player.job === 'thief') {
                ctx.fillStyle = '#442266';
                ctx.beginPath();
                ctx.moveTo(px + 5, py + 15);
                ctx.lineTo(px + 20, py - 5);
                ctx.lineTo(px + 35, py + 15);
                ctx.fill();
            } else if (player.job === 'archer') {
                ctx.fillStyle = '#228844';
                ctx.beginPath();
                ctx.arc(px + player.width/2, py + 10, 13, Math.PI, Math.PI * 2);
                ctx.fill();
                // Î™®Ïûê
                ctx.fillStyle = '#116633';
                ctx.beginPath();
                ctx.moveTo(px + 10, py + 5);
                ctx.lineTo(px + 20, py - 10);
                ctx.lineTo(px + 30, py + 5);
                ctx.fill();
            }

            // Îàà
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(px + player.width/2 + 5, py + 15, 2, 0, Math.PI * 2);
            ctx.fill();

            // Îã§Î¶¨
            ctx.fillStyle = '#333';
            ctx.fillRect(px + 10, py + 50, 8, 10);
            ctx.fillRect(px + 22, py + 50, 8, 10);

            // Î¨¥Í∏∞
            if (player.job === 'warrior') {
                ctx.fillStyle = '#888';
                ctx.fillRect(px + 35, py + 25, 8, 35);
                ctx.fillStyle = '#ffcc00';
                ctx.fillRect(px + 33, py + 22, 12, 8);
            } else if (player.job === 'thief') {
                ctx.fillStyle = '#666';
                ctx.beginPath();
                ctx.moveTo(px + 40, py + 30);
                ctx.lineTo(px + 55, py + 25);
                ctx.lineTo(px + 55, py + 35);
                ctx.closePath();
                ctx.fill();
            } else if (player.job === 'archer') {
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(px + 35, py + 30, 20, -Math.PI/2, Math.PI/2);
                ctx.stroke();
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(px + 35, py + 10);
                ctx.lineTo(px + 35, py + 50);
                ctx.stroke();
            }

            // Í≥µÍ≤© Ïù¥ÌéôÌä∏
            if (player.isAttacking) {
                ctx.fillStyle = `rgba(${job ? '255, 255, 100' : '255, 255, 100'}, 0.6)`;
                ctx.beginPath();
                ctx.arc(px + player.width + 30, py + 30, 35, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function gameLoop() {
            if (!game.started) {
                requestAnimationFrame(gameLoop);
                return;
            }

            // MP ÌöåÎ≥µ
            if (player.mp < player.maxMp) {
                player.mp += 0.05;
            }

            // Î≤ÑÌîÑ ÏóÖÎç∞Ïù¥Ìä∏
            for (const [buffName, buffData] of Object.entries(player.buffs)) {
                if (buffData.duration > 0) {
                    buffData.duration--;
                    if (buffData.duration <= 0) {
                        delete player.buffs[buffName];
                    }
                }
            }
            updateBuffBar();

            // Ïä§ÌÇ¨ Ïø®Îã§Ïö¥
            for (let i = 0; i < player.skillCooldowns.length; i++) {
                if (player.skillCooldowns[i] > 0) player.skillCooldowns[i]--;
            }
            updateSkillBar();

            // Ïù¥Îèô ÏÜçÎèÑ Í≥ÑÏÇ∞
            let currentSpeed = player.speed;
            if (player.buffs.haste && player.buffs.haste.duration > 0) {
                currentSpeed *= player.buffs.haste.speedBonus;
            }

            if (game.keys['ArrowLeft'] || game.keys['KeyA']) {
                player.vx = -currentSpeed;
                player.direction = -1;
            } else if (game.keys['ArrowRight'] || game.keys['KeyD']) {
                player.vx = currentSpeed;
                player.direction = 1;
            } else {
                player.vx *= 0.8;
            }

            if ((game.keys['ArrowUp'] || game.keys['Space'] || game.keys['KeyW']) && !player.isJumping) {
                player.vy = player.jumpPower;
                player.isJumping = true;
            }

            player.x += player.vx;
            player.vy += game.gravity;
            player.y += player.vy;

            player.isJumping = true;
            for (const p of game.platforms) {
                if (player.y + player.height > p.y &&
                    player.y + player.height < p.y + p.height + 10 &&
                    player.x + player.width > p.x &&
                    player.x < p.x + p.width &&
                    player.vy >= 0) {
                    player.y = p.y - player.height;
                    player.vy = 0;
                    player.isJumping = false;
                }
            }

            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            if (player.y > canvas.height) {
                player.y = 100;
                player.hp -= 20;
                updateUI();
            }

            if (player.invincible > 0) player.invincible--;

            spawnMonster();
            game.monsters = game.monsters.filter(m => !m.update());
            game.projectiles = game.projectiles.filter(p => !p.update());

            game.particles = game.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                if (!p.isArrow) p.vy += 0.2;
                p.life--;
                return p.life > 0;
            });

            game.damageTexts = game.damageTexts.filter(t => {
                t.y += t.vy;
                t.life--;
                return t.life > 0;
            });

            if (player.hp <= 0) {
                player.hp = player.maxHp;
                player.mp = player.maxMp;
                player.x = 100;
                player.y = 400;
                player.exp = Math.floor(player.exp / 2);
                updateUI();
            }

            // Î†åÎçîÎßÅ
            drawBackground();

            for (const monster of game.monsters) {
                monster.draw();
            }

            drawPlayer();

            for (const proj of game.projectiles) {
                proj.draw();
            }

            for (const p of game.particles) {
                ctx.globalAlpha = p.life / 30;
                ctx.fillStyle = p.color;
                if (p.isArrow) {
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x - 3, p.y - 15);
                    ctx.lineTo(p.x + 3, p.y - 15);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;

            for (const t of game.damageTexts) {
                ctx.globalAlpha = t.life / 60;
                ctx.fillStyle = t.color;
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(t.damage, t.x, t.y);
            }
            ctx.globalAlpha = 1;

            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (e) => {
            game.keys[e.code] = true;
            if (e.code === 'KeyZ') useSkill(0);
            if (e.code === 'KeyX') useSkill(1);
            if (e.code === 'KeyC') useSkill(2);
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            game.keys[e.code] = false;
        });

        gameLoop();
    </script>
</body>
</html>
