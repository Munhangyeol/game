<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapleQuest RPG</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', sans-serif;
        }
        .game-container { position: relative; }
        canvas {
            border: 4px solid #4a4a6a;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(100, 100, 255, 0.3);
        }
        .ui-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        .stat-bar {
            width: 200px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin: 5px 0;
            overflow: hidden;
            border: 2px solid #555;
        }
        .hp-fill { height: 100%; background: linear-gradient(90deg, #ff4444, #ff6666); transition: width 0.3s; }
        .mp-fill { height: 100%; background: linear-gradient(90deg, #4444ff, #6666ff); transition: width 0.3s; }
        .exp-fill { height: 100%; background: linear-gradient(90deg, #44ff44, #66ff66); transition: width 0.3s; }
        .controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #aaa;
            font-size: 12px;
            transition: opacity 1s ease-out;
            opacity: 1;
        }
        .controls.fade-out {
            opacity: 0;
        }
        .level-up {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffff00;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 20px #ffff00;
            animation: levelUp 2s ease-out forwards;
            pointer-events: none;
            display: none;
            text-align: center;
        }
        .stat-gain {
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translate(-50%, 0);
            color: #44ff44;
            font-size: 20px;
            text-shadow: 0 0 10px #44ff44;
            pointer-events: none;
            display: none;
            animation: levelUp 1.5s ease-out forwards;
        }
        @keyframes levelUp {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -100%) scale(1); }
        }
        @keyframes hpPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .hp-fill-danger {
            animation: hpPulse 0.8s ease-in-out infinite;
        }
        .job-select {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            border-radius: 8px;
        }
        .job-select h1 { color: #ffcc00; font-size: 36px; margin-bottom: 10px; text-shadow: 0 0 20px #ffcc00; }
        .job-select p { color: #aaa; margin-bottom: 30px; }
        .job-cards { display: flex; gap: 20px; }
        .job-card {
            width: 200px;
            padding: 20px;
            background: linear-gradient(135deg, #2a2a4a, #1a1a3a);
            border: 3px solid #4a4a6a;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        .job-card:hover {
            transform: translateY(-10px);
            border-color: #ffcc00;
            box-shadow: 0 10px 30px rgba(255, 204, 0, 0.3);
        }
        .job-card h2 { color: #fff; margin-bottom: 10px; }
        .job-card .job-icon { font-size: 60px; margin: 15px 0; }
        .job-card .job-stats { color: #aaa; font-size: 12px; text-align: left; margin-top: 15px; }
        .job-card .job-stats div { margin: 5px 0; }
        .job-card.warrior { border-top: 4px solid #ff6644; }
        .job-card.thief { border-top: 4px solid #aa44ff; }
        .job-card.archer { border-top: 4px solid #44ff66; }
        .job-card.warrior:hover { border-color: #ff6644; box-shadow: 0 10px 30px rgba(255, 102, 68, 0.3); }
        .job-card.thief:hover { border-color: #aa44ff; box-shadow: 0 10px 30px rgba(170, 68, 255, 0.3); }
        .job-card.archer:hover { border-color: #44ff66; box-shadow: 0 10px 30px rgba(68, 255, 102, 0.3); }
        .skill-bar {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        .skill-slot {
            width: 50px; height: 50px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #555;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 10px;
            position: relative;
        }
        .skill-slot .key {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            padding: 1px 5px;
            border-radius: 3px;
            font-size: 9px;
        }
        .skill-slot .cooldown {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            font-weight: bold;
            border-radius: 6px;
            pointer-events: none;
            z-index: 10;
        }
        .skill-slot canvas.cd-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        .skill-slot.ready {
            border-color: #44ff44;
            box-shadow: 0 0 10px rgba(68, 255, 68, 0.5);
            animation: skillReady 0.5s ease-out;
        }
        @keyframes skillReady {
            0% { box-shadow: 0 0 10px rgba(68, 255, 68, 0.5); }
            50% { box-shadow: 0 0 20px rgba(68, 255, 68, 1); }
            100% { box-shadow: 0 0 10px rgba(68, 255, 68, 0.5); }
        }
        @keyframes skillPress {
            0% { transform: scale(1); }
            50% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }
        @keyframes skillShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }
        .skill-slot.press { animation: skillPress 0.2s ease-out; }
        .skill-slot.shake { animation: skillShake 0.3s ease-out; }
        .buff-bar {
            position: absolute;
            top: 160px;
            left: 10px;
            display: flex;
            gap: 5px;
        }
        .buff-icon {
            width: 40px; height: 45px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #ffcc00;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            position: relative;
        }
        .buff-time {
            font-size: 9px;
            color: #fff;
            font-weight: bold;
            margin-top: 2px;
        }
        .buff-time.warning {
            color: #ffaa00;
        }
        .buff-time.critical {
            color: #ff4444;
            animation: buffBlink 0.5s infinite;
        }
        @keyframes buffBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="1000" height="600"></canvas>

        <div class="job-select" id="jobSelect">
            <h1>ÏßÅÏóÖÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</h1>
            <p>Í∞Å ÏßÅÏóÖÏùÄ Í≥†Ïú†Ìïú Ïä§ÌÉØÍ≥º Ïä§ÌÇ¨ÏùÑ Í∞ÄÏßÄÍ≥† ÏûàÏäµÎãàÎã§</p>
            <div class="job-cards">
                <div class="job-card warrior" onclick="selectJob('warrior')">
                    <h2 style="color: #ff6644">Ï†ÑÏÇ¨</h2>
                    <div class="job-icon">‚öîÔ∏è</div>
                    <div class="job-stats">
                        <div>‚ù§Ô∏è HP: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ</div>
                        <div>‚ö° ÏÜçÎèÑ: ‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ</div>
                        <div>üí™ Í≥µÍ≤©Î†•: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ</div>
                        <div style="color: #ff6644; margin-top: 10px;">
                            <b>Ïä§ÌÇ¨:</b><br>
                            [A] Í∏∞Î≥∏Í≥µÍ≤© - Í≤Ä ÌúòÎëêÎ•¥Í∏∞<br>
                            [Z] üí• ÌååÏõå Ïä§Ìä∏ÎùºÏù¥ÌÅ¨<br>
                            [X] üåÄ Ïä¨ÎûòÏãú Î∏îÎûòÏä§Ìä∏<br>
                            [C] üò§ Î†àÏù¥ÏßÄ (Î≤ÑÌîÑ)
                        </div>
                    </div>
                </div>
                <div class="job-card thief" onclick="selectJob('thief')">
                    <h2 style="color: #aa44ff">ÎèÑÏ†Å</h2>
                    <div class="job-icon">üó°Ô∏è</div>
                    <div class="job-stats">
                        <div>‚ù§Ô∏è HP: ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ</div>
                        <div>‚ö° ÏÜçÎèÑ: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ</div>
                        <div>üí™ Í≥µÍ≤©Î†•: ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ</div>
                        <div style="color: #aa44ff; margin-top: 10px;">
                            <b>Ïä§ÌÇ¨:</b><br>
                            [A] Í∏∞Î≥∏Í≥µÍ≤© - Îã®Í≤Ä ÎÇúÎ¨¥<br>
                            [Z] ‚ö° ÏÇºÏ§ë Ïä§ÌÉ≠<br>
                            [X] üíÄ Ïñ¥ÏåîÏãúÎÑ§Ïù¥Ìä∏<br>
                            [C] üí® Ìó§Ïù¥Ïä§Ìä∏ (Î≤ÑÌîÑ)
                        </div>
                    </div>
                </div>
                <div class="job-card archer" onclick="selectJob('archer')">
                    <h2 style="color: #44ff66">Í∂ÅÏàò</h2>
                    <div class="job-icon">üèπ</div>
                    <div class="job-stats">
                        <div>‚ù§Ô∏è HP: ‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ</div>
                        <div>‚ö° ÏÜçÎèÑ: ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ</div>
                        <div>üí™ Í≥µÍ≤©Î†•: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ</div>
                        <div style="color: #44ff66; margin-top: 10px;">
                            <b>Ïä§ÌÇ¨:</b><br>
                            [A] Í∏∞Î≥∏Í≥µÍ≤© - ÌôîÏÇ¥ Î∞úÏÇ¨<br>
                            [Z] ‚ûπ ÎçîÎ∏î ÏÉ∑<br>
                            [X] üåßÔ∏è Ïï†Î°úÏö∞ Î†àÏù∏<br>
                            [C] ‚ú® ÏÜåÏö∏ Ïï†Î°úÏö∞ (Î≤ÑÌîÑ)
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="ui-overlay" id="gameUI" style="display: none;">
            <div><span id="jobIcon">‚öîÔ∏è</span> Lv. <span id="level">1</span> <span id="jobName">Ï†ÑÏÇ¨</span></div>
            <div class="stat-bar"><div class="hp-fill" id="hpBar" style="width: 100%"></div></div>
            <div style="font-size: 12px">HP: <span id="hpText">100/100</span></div>
            <div class="stat-bar"><div class="mp-fill" id="mpBar" style="width: 100%"></div></div>
            <div style="font-size: 12px">MP: <span id="mpText">50/50</span></div>
            <div class="stat-bar"><div class="exp-fill" id="expBar" style="width: 0%"></div></div>
            <div style="font-size: 12px">EXP: <span id="expText">0/100</span></div>
            <div style="margin-top: 10px">‚öîÔ∏è Í≥µÍ≤©Î†•: <span id="attack">10</span></div>
            <div>üí• ÌÅ¨Î¶¨Ìã∞Ïª¨: <span id="crit">10</span>%</div>
            <div>üíÄ Ï≤òÏπò: <span id="kills">0</span></div>
        </div>

        <div class="buff-bar" id="buffBar"></div>
        <div class="skill-bar" id="skillBar"></div>
        <div class="controls" id="controlsUI" style="display: none;">
            [‚Üê‚Üí] Ïù¥Îèô | [‚Üë/Space] Ï†êÌîÑ | [A] Í∏∞Î≥∏Í≥µÍ≤© | [Z][X][C] Ïä§ÌÇ¨
        </div>
        <div class="level-up" id="levelUpText">LEVEL UP!</div>
        <div class="stat-gain" id="statGainText"></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ÏßÅÏóÖ Ï†ïÏùò
        const JOBS = {
            warrior: {
                name: 'Ï†ÑÏÇ¨',
                icon: '‚öîÔ∏è',
                color: '#ff6644',
                baseHp: 150,
                baseMp: 30,
                baseAttack: 15,
                speed: 4,
                jumpPower: -13,
                critChance: 10,
                hpPerLevel: 30,
                mpPerLevel: 5,
                attackPerLevel: 7,
                promotionBonus: [
                    { level: 10, hp: 100, mp: 20 },  // Ï¥àÎ≥ÄÏßÅ (Í∏∞ÏÇ¨)
                    { level: 30, hp: 200, mp: 40 },  // Ïû¨Î≥ÄÏßÅ (Îã§ÌÅ¨ÎÇòÏù¥Ìä∏)
                    { level: 70, hp: 400, mp: 80 }   // ÏµúÏ¢ÖÎ≥ÄÏßÅ (ÌûàÏñ¥Î°ú)
                ],
                basicAttack: { damage: 1.4, range: 75, type: 'sword', cooldown: 28, animDuration: 200 },
                skills: [
                    { name: 'ÌååÏõå Ïä§Ìä∏ÎùºÏù¥ÌÅ¨', key: 'Z', mp: 5, cooldown: 30, damage: 2.8, type: 'powerStrike', knockback: true, icon: 'üí•' },
                    { name: 'Ïä¨ÎûòÏãú Î∏îÎûòÏä§Ìä∏', key: 'X', mp: 10, cooldown: 90, damage: 1.5, type: 'slashBlast', range: 150, icon: 'üåÄ' },
                    { name: 'Î†àÏù¥ÏßÄ', key: 'C', mp: 15, cooldown: 600, duration: 600, buff: 'rage', attackBonus: 1.5, icon: 'üò§' }
                ]
            },
            thief: {
                name: 'ÎèÑÏ†Å',
                icon: 'üó°Ô∏è',
                color: '#aa44ff',
                baseHp: 100,
                baseMp: 50,
                baseAttack: 12,
                speed: 7,
                jumpPower: -14,
                critChance: 25,
                hpPerLevel: 20,
                mpPerLevel: 8,
                attackPerLevel: 5,
                promotionBonus: [
                    { level: 10, hp: 80, mp: 30 },   // Ï¥àÎ≥ÄÏßÅ (Î°úÍ∑∏)
                    { level: 30, hp: 150, mp: 60 },  // Ïû¨Î≥ÄÏßÅ (Ïñ¥ÏåîÏã†)
                    { level: 70, hp: 300, mp: 120 }  // ÏµúÏ¢ÖÎ≥ÄÏßÅ (ÎÇòÏù¥Ìä∏Î°úÎìú)
                ],
                basicAttack: { damage: 0.4, range: 50, type: 'dagger', hits: 2, cooldown: 10, animDuration: 60 },
                skills: [
                    { name: 'ÏÇºÏ§ë Ïä§ÌÉ≠', key: 'Z', mp: 5, cooldown: 35, damage: 1.4, hits: 3, type: 'doubleStab', icon: '‚ö°' },
                    { name: 'Ïñ¥ÏåîÏãúÎÑ§Ïù¥Ìä∏', key: 'X', mp: 12, cooldown: 120, damage: 4.5, type: 'assassinate', backstab: true, icon: 'üíÄ' },
                    { name: 'Ìó§Ïù¥Ïä§Ìä∏', key: 'C', mp: 10, cooldown: 480, duration: 600, buff: 'haste', speedBonus: 1.5, icon: 'üí®' }
                ]
            },
            archer: {
                name: 'Í∂ÅÏàò',
                icon: 'üèπ',
                color: '#44ff66',
                baseHp: 80,
                baseMp: 40,
                baseAttack: 18,
                speed: 5,
                jumpPower: -13,
                critChance: 20,
                hpPerLevel: 15,
                mpPerLevel: 7,
                attackPerLevel: 8,
                promotionBonus: [
                    { level: 10, hp: 70, mp: 25 },   // Ï¥àÎ≥ÄÏßÅ (ÌóåÌÑ∞)
                    { level: 30, hp: 130, mp: 50 },  // Ïû¨Î≥ÄÏßÅ (Î†àÏù∏Ï†Ä)
                    { level: 70, hp: 250, mp: 100 }  // ÏµúÏ¢ÖÎ≥ÄÏßÅ (Î≥¥Ïö∞ÎßàÏä§ÌÑ∞)
                ],
                basicAttack: { damage: 1.0, type: 'arrow', cooldown: 18, animDuration: 100 },
                skills: [
                    { name: 'ÎçîÎ∏î ÏÉ∑', key: 'Z', mp: 3, cooldown: 20, damage: 1.8, arrows: 2, type: 'doubleShot', spread: true, icon: '‚ûπ' },
                    { name: 'Ïï†Î°úÏö∞ Î†àÏù∏', key: 'X', mp: 15, cooldown: 150, damage: 1.0, type: 'arrowRain', icon: 'üåßÔ∏è' },
                    { name: 'ÏÜåÏö∏ Ïï†Î°úÏö∞', key: 'C', mp: 8, cooldown: 420, duration: 600, buff: 'soul', piercing: true, icon: '‚ú®' }
                ]
            }
        };

        // Í≤åÏûÑ ÏÉÅÌÉú
        const game = {
            started: false,
            gravity: 0.6,
            platforms: [
                { x: 0, y: 500, width: 1000, height: 100 },
                { x: 150, y: 400, width: 150, height: 20 },
                { x: 420, y: 350, width: 160, height: 20 },
                { x: 700, y: 400, width: 150, height: 20 },
                { x: 50, y: 280, width: 120, height: 20 },
                { x: 550, y: 250, width: 120, height: 20 },
                { x: 820, y: 280, width: 120, height: 20 },
            ],
            monsters: [],
            particles: [],
            damageTexts: [],
            projectiles: [],
            effects: [],
            keys: {},
            lastMonsterSpawn: 0,
            monsterSpawnInterval: 2500,
        };

        // ÌîåÎ†àÏù¥Ïñ¥
        const player = {
            x: 100, y: 400,
            width: 40, height: 60,
            vx: 0, vy: 0,
            speed: 5,
            jumpPower: -14,
            isJumping: false,
            direction: 1,
            isAttacking: false,
            attackCooldown: 0,
            hp: 100, maxHp: 100,
            mp: 50, maxMp: 50,
            exp: 0, expToLevel: 100,
            level: 1,
            attack: 10,
            critChance: 10,
            kills: 0,
            invincible: 0,
            job: null,
            skillCooldowns: [0, 0, 0],
            buffs: {},
        };

        // Ïù¥ÌéôÌä∏ ÌÅ¥ÎûòÏä§
        class Effect {
            constructor(type, x, y, direction, data = {}) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.direction = direction;
                this.frame = 0;
                this.maxFrames = data.maxFrames || 20;
                this.data = data;
            }

            update() {
                this.frame++;
                return this.frame >= this.maxFrames;
            }

            draw() {
                ctx.save();
                const progress = this.frame / this.maxFrames;

                switch(this.type) {
                    case 'swordSlash':
                        this.drawSwordSlash(progress);
                        break;
                    case 'powerStrike':
                        this.drawPowerStrike(progress);
                        break;
                    case 'slashBlast':
                        this.drawSlashBlast(progress);
                        break;
                    case 'daggerSlash':
                        this.drawDaggerSlash(progress);
                        break;
                    case 'doubleStab':
                        this.drawDoubleStab(progress);
                        break;
                    case 'assassinate':
                        this.drawAssassinate(progress);
                        break;
                    case 'arrowTrail':
                        this.drawArrowTrail(progress);
                        break;
                    case 'doubleShot':
                        this.drawDoubleShot(progress);
                        break;
                    case 'arrowRain':
                        this.drawArrowRain(progress);
                        break;
                    case 'rageActivate':
                        this.drawRageActivate(progress);
                        break;
                    case 'hasteActivate':
                        this.drawHasteActivate(progress);
                        break;
                    case 'soulActivate':
                        this.drawSoulActivate(progress);
                        break;
                }

                ctx.restore();
            }

            drawSwordSlash(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = '#ffaa44';
                ctx.lineWidth = 4 - progress * 3;
                ctx.lineCap = 'round';

                const startAngle = this.direction === 1 ? -Math.PI/3 : Math.PI + Math.PI/3;
                const endAngle = this.direction === 1 ? Math.PI/3 : Math.PI - Math.PI/3;
                const currentAngle = startAngle + (endAngle - startAngle) * Math.min(1, progress * 2);

                ctx.beginPath();
                ctx.arc(this.x, this.y, 50 + progress * 20, startAngle, currentAngle);
                ctx.stroke();

                // Í≤Ä Í∂§Ï†Å Îπõ
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 45 + progress * 20, startAngle, currentAngle);
                ctx.stroke();
            }

            drawPowerStrike(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                // Í∞ïÎ†•Ìïú Ï∂©Í≤©Ìåå
                const radius = 30 + progress * 80;
                ctx.strokeStyle = '#ff6644';
                ctx.lineWidth = 8 - progress * 6;
                ctx.beginPath();
                ctx.arc(this.x + this.direction * 40, this.y, radius, 0, Math.PI * 2);
                ctx.stroke();

                // ÎÇ¥Î∂Ä Ìè≠Î∞ú
                ctx.fillStyle = `rgba(255, 150, 50, ${alpha * 0.5})`;
                ctx.beginPath();
                ctx.arc(this.x + this.direction * 40, this.y, radius * 0.6, 0, Math.PI * 2);
                ctx.fill();

                // Ïä§ÌååÌÅ¨
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + progress * 2;
                    const dist = radius * 0.8;
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(
                        this.x + this.direction * 40 + Math.cos(angle) * dist,
                        this.y + Math.sin(angle) * dist,
                        4 - progress * 3, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }

            drawSlashBlast(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                // Îã§Ï§ë ÏõêÌòï Ïä¨ÎûòÏãú
                for (let i = 0; i < 3; i++) {
                    const delay = i * 0.15;
                    const p = Math.max(0, progress - delay) / (1 - delay);
                    if (p > 0 && p < 1) {
                        const radius = 50 + p * 100;
                        ctx.strokeStyle = i === 0 ? '#ff6644' : (i === 1 ? '#ff9966' : '#ffcc88');
                        ctx.lineWidth = 6 - p * 5;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                // Ïä¨ÎûòÏãú ÎùºÏù∏Îì§
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const len = 60 + progress * 80;
                    ctx.strokeStyle = '#ffaa44';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(this.x + Math.cos(angle) * 20, this.y + Math.sin(angle) * 20);
                    ctx.lineTo(this.x + Math.cos(angle) * len, this.y + Math.sin(angle) * len);
                    ctx.stroke();
                }
            }

            drawDaggerSlash(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                // Îπ†Î•∏ Îã®Í≤Ä Í∂§Ï†Å (2Í∞ú)
                for (let i = 0; i < 2; i++) {
                    const offset = i * 0.3;
                    const p = Math.max(0, Math.min(1, (progress - offset) * 2));

                    ctx.strokeStyle = i === 0 ? '#aa44ff' : '#dd88ff';
                    ctx.lineWidth = 3 - p * 2;
                    ctx.lineCap = 'round';

                    const startX = this.x + this.direction * 10;
                    const endX = this.x + this.direction * (40 + p * 20);
                    const offsetY = (i - 0.5) * 20;

                    ctx.beginPath();
                    ctx.moveTo(startX, this.y + offsetY - 10);
                    ctx.lineTo(endX, this.y + offsetY + 10);
                    ctx.stroke();
                }

                // Ïä§ÌîºÎìú ÎùºÏù∏
                ctx.strokeStyle = 'rgba(170, 68, 255, 0.5)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                    const y = this.y - 20 + i * 10;
                    ctx.beginPath();
                    ctx.moveTo(this.x - this.direction * 30, y);
                    ctx.lineTo(this.x + this.direction * 20, y);
                    ctx.stroke();
                }
            }

            drawDoubleStab(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;
                const numHits = this.data.hits || 2;
                const colors = ['#aa44ff', '#cc66ff', '#ee88ff'];
                const gap = 0.75 / numHits;

                for (let i = 0; i < numHits; i++) {
                    const offset = i * gap;
                    const p = Math.max(0, Math.min(1, (progress - offset) / (1 - offset) * 1.8));

                    if (p > 0) {
                        const length = 60 * (1 - Math.abs(p - 0.5) * 2);
                        const yOff = (i - numHits * 0.3) * 10;
                        ctx.fillStyle = colors[i] || '#ee88ff';
                        ctx.beginPath();
                        ctx.moveTo(this.x + this.direction * 20, this.y - 5 + yOff);
                        ctx.lineTo(this.x + this.direction * (20 + length), this.y + yOff);
                        ctx.lineTo(this.x + this.direction * 20, this.y + 5 + yOff);
                        ctx.fill();

                        if (p > 0.4 && p < 0.6) {
                            ctx.fillStyle = '#ffffff';
                            ctx.beginPath();
                            ctx.arc(this.x + this.direction * 80, this.y + yOff, 10, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }

            drawAssassinate(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                // Í∑∏Î¶ºÏûê Î∂ÑÏã†
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.7})`;
                for (let i = 0; i < 3; i++) {
                    const offsetX = this.direction * (i * 30 - progress * 60);
                    ctx.beginPath();
                    ctx.ellipse(this.x + offsetX, this.y, 25 - i * 5, 35 - i * 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ÏπòÎ™ÖÏ†Å ÏùºÍ≤©
                const strikeProgress = Math.max(0, progress - 0.3) / 0.7;
                if (strikeProgress > 0) {
                    // XÏûê Ïä¨ÎûòÏãú
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 5 - strikeProgress * 4;
                    ctx.lineCap = 'round';

                    const size = 40 + strikeProgress * 30;
                    const cx = this.x + this.direction * 60;

                    ctx.beginPath();
                    ctx.moveTo(cx - size, this.y - size);
                    ctx.lineTo(cx + size, this.y + size);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(cx + size, this.y - size);
                    ctx.lineTo(cx - size, this.y + size);
                    ctx.stroke();

                    // Ìï¥Í≥® Ïù¥ÌéôÌä∏
                    if (strikeProgress > 0.5) {
                        ctx.font = `${30 + strikeProgress * 20}px Arial`;
                        ctx.fillStyle = `rgba(255, 0, 0, ${1 - strikeProgress})`;
                        ctx.textAlign = 'center';
                        ctx.fillText('üíÄ', cx, this.y + 10);
                    }
                }
            }

            drawArrowTrail(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                // ÌôîÏÇ¥ Í∂§Ï†Å
                ctx.strokeStyle = '#44ff66';
                ctx.lineWidth = 3 - progress * 2;
                ctx.lineCap = 'round';

                const length = 40;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + this.direction * length, this.y);
                ctx.stroke();

                // Î∞îÎûå Ìö®Í≥º
                ctx.strokeStyle = 'rgba(200, 255, 200, 0.5)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    const offsetY = (i - 1) * 8;
                    ctx.beginPath();
                    ctx.moveTo(this.x - this.direction * 20, this.y + offsetY);
                    ctx.lineTo(this.x - this.direction * 50, this.y + offsetY);
                    ctx.stroke();
                }
            }

            drawDoubleShot(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                // Îëê Í∞úÏùò ÌôîÏÇ¥ Í∂§Ï†Å
                for (let i = 0; i < 2; i++) {
                    const offsetY = (i - 0.5) * 20;
                    const trailLength = 80 * (1 - progress);

                    // ÌôîÏÇ¥ Îπõ Í∂§Ï†Å
                    const gradient = ctx.createLinearGradient(
                        this.x, this.y + offsetY,
                        this.x + this.direction * trailLength, this.y + offsetY
                    );
                    gradient.addColorStop(0, 'rgba(68, 255, 102, 0)');
                    gradient.addColorStop(1, `rgba(68, 255, 102, ${alpha})`);

                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + offsetY);
                    ctx.lineTo(this.x + this.direction * trailLength, this.y + offsetY);
                    ctx.stroke();

                    // ÌôîÏÇ¥Ï¥â
                    ctx.fillStyle = '#88ff88';
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.direction * trailLength, this.y + offsetY);
                    ctx.lineTo(this.x + this.direction * (trailLength - 15), this.y + offsetY - 5);
                    ctx.lineTo(this.x + this.direction * (trailLength - 15), this.y + offsetY + 5);
                    ctx.fill();
                }
            }

            drawArrowRain(progress) {
                const alpha = 1 - progress * 0.5;
                ctx.globalAlpha = alpha;

                // ÌïòÎäòÏóêÏÑú ÎÇ¥Î¶¨Îäî ÌôîÏÇ¥Îì§
                const numArrows = 15;
                for (let i = 0; i < numArrows; i++) {
                    const delay = (i / numArrows) * 0.6;
                    const p = Math.max(0, (progress - delay) / (1 - delay));

                    if (p > 0 && p < 1) {
                        const x = this.data.startX + (i / numArrows) * this.data.width;
                        const startY = -50;
                        const endY = this.data.groundY || 480;
                        const y = startY + (endY - startY) * p;

                        // ÌôîÏÇ¥
                        ctx.fillStyle = '#44ff66';
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x - 4, y - 25);
                        ctx.lineTo(x + 4, y - 25);
                        ctx.fill();

                        // ÌôîÏÇ¥ Íº¨Î¶¨
                        ctx.strokeStyle = 'rgba(68, 255, 102, 0.5)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x, y - 25);
                        ctx.lineTo(x, y - 60);
                        ctx.stroke();

                        // Ï∞©ÏßÄ Ïù¥ÌéôÌä∏
                        if (p > 0.9) {
                            ctx.fillStyle = `rgba(68, 255, 102, ${(1 - p) * 5})`;
                            ctx.beginPath();
                            ctx.arc(x, endY, 20 * (p - 0.9) * 10, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }

            drawRageActivate(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                const radius = 10 + progress * 65;
                ctx.strokeStyle = '#ff4400';
                ctx.lineWidth = 7 - progress * 6;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.stroke();

                ctx.fillStyle = `rgba(255, 80, 0, ${alpha * 0.5})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius * 0.45, 0, Math.PI * 2);
                ctx.fill();

                for (let i = 0; i < 14; i++) {
                    const angle = (i / 14) * Math.PI * 2 + progress * 5;
                    const dist = 15 + progress * 55;
                    ctx.fillStyle = i % 2 === 0 ? '#ff6600' : '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(
                        this.x + Math.cos(angle) * dist,
                        this.y + Math.sin(angle) * dist,
                        5 - progress * 4, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }

            drawHasteActivate(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2 + progress * 3;
                    const startDist = 8 + progress * 15;
                    const endDist = 25 + progress * 55;

                    ctx.strokeStyle = `rgba(170, 68, 255, ${alpha * (1 - progress * 0.5)})`;
                    ctx.lineWidth = 3 - progress * 2;
                    ctx.beginPath();
                    ctx.moveTo(
                        this.x + Math.cos(angle) * startDist,
                        this.y + Math.sin(angle) * startDist
                    );
                    ctx.lineTo(
                        this.x + Math.cos(angle) * endDist,
                        this.y + Math.sin(angle) * endDist
                    );
                    ctx.stroke();
                }

                ctx.strokeStyle = `rgba(200, 160, 255, ${alpha * 0.6})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 20 + progress * 40, 0, Math.PI * 2);
                ctx.stroke();
            }

            drawSoulActivate(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                for (let i = 0; i < 3; i++) {
                    const delay = i * 0.22;
                    const p = Math.max(0, (progress - delay) / (1 - delay));
                    if (p > 0) {
                        const radius = 8 + p * 65;
                        ctx.strokeStyle = `rgba(68, 255, 200, ${alpha * (1 - p * 0.4)})`;
                        ctx.lineWidth = 4 - p * 3;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + progress * 4;
                    const dist = 12 + progress * 42;
                    ctx.fillStyle = `rgba(150, 255, 220, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(
                        this.x + Math.cos(angle) * dist,
                        this.y + Math.sin(angle) * dist,
                        3 - progress * 2.5, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }
        }

        // Ìà¨ÏÇ¨Ï≤¥ ÌÅ¥ÎûòÏä§
        class Projectile {
            constructor(x, y, direction, damage, type = 'arrow', piercing = false, vy = 0) {
                this.x = x;
                this.y = y;
                this.direction = direction;
                this.speed = 14;
                this.damage = damage;
                this.type = type;
                this.piercing = piercing;
                this.hitMonsters = new Set();
                this.life = 100;
                this.trail = [];
                this.vy = vy;
            }

            update() {
                // Í∂§Ï†Å Ï†ÄÏû•
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 10) this.trail.shift();

                this.x += this.speed * this.direction;
                this.y += this.vy;
                this.life--;

                if (this.x < -50 || this.x > canvas.width + 50) return true;

                for (const monster of game.monsters) {
                    if (!monster.isDead && !this.hitMonsters.has(monster) &&
                        this.x > monster.x && this.x < monster.x + monster.width &&
                        this.y > monster.y && this.y < monster.y + monster.height) {
                        const isCrit = Math.random() * 100 < player.critChance;
                        monster.takeDamage(this.damage, isCrit);
                        this.hitMonsters.add(monster);

                        // ÌûàÌä∏ Ïù¥ÌéôÌä∏
                        createParticles(this.x, this.y, '#44ff66', 5);

                        if (!this.piercing) return true;
                    }
                }

                return this.life <= 0;
            }

            draw() {
                ctx.save();

                // Í∂§Ï†Å Í∑∏Î¶¨Í∏∞
                if (this.trail.length > 1) {
                    ctx.strokeStyle = player.buffs.soul ? 'rgba(0, 255, 255, 0.3)' : 'rgba(68, 255, 102, 0.3)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.stroke();
                }

                ctx.translate(this.x, this.y);
                if (this.direction === -1) ctx.scale(-1, 1);

                // ÌôîÏÇ¥ Î≥∏Ï≤¥
                const arrowColor = player.buffs.soul ? '#00ffff' : '#8B4513';

                // ÌôîÏÇ¥ÎåÄ
                ctx.fillStyle = arrowColor;
                ctx.fillRect(-20, -2, 25, 4);

                // ÌôîÏÇ¥Ï¥â
                ctx.fillStyle = '#aaaaaa';
                ctx.beginPath();
                ctx.moveTo(10, 0);
                ctx.lineTo(0, -5);
                ctx.lineTo(0, 5);
                ctx.fill();

                // ÍπÉÌÑ∏
                ctx.fillStyle = '#44ff66';
                ctx.beginPath();
                ctx.moveTo(-20, 0);
                ctx.lineTo(-28, -6);
                ctx.lineTo(-25, 0);
                ctx.lineTo(-28, 6);
                ctx.fill();

                // ÏÜåÏö∏ Ïï†Î°úÏö∞ Ïù¥ÌéôÌä∏
                if (player.buffs.soul && player.buffs.soul.duration > 0) {
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 12, 0, Math.PI * 2);
                    ctx.fill();

                    // ÎπõÎÇòÎäî ÏûÖÏûê
                    for (let i = 0; i < 3; i++) {
                        const angle = Date.now() / 200 + i * Math.PI * 2 / 3;
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(Math.cos(angle) * 8, Math.sin(angle) * 8, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.restore();
            }
        }

        // Î™¨Ïä§ÌÑ∞ ÌÅ¥ÎûòÏä§
        class Monster {
            constructor(x, y, type = 'slime') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.spawnLevel = player.level; // ÏÉùÏÑ± ÏãúÏ†ê ÌîåÎ†àÏù¥Ïñ¥ Î†àÎ≤® Ï†ÄÏû•

                const monsterTypes = {
                    slime: { width: 50, height: 40, hp: 30 + player.level * 10, damage: 8 + player.level * 2, exp: 25, color: '#44dd44' },
                    mushroom: { width: 55, height: 50, hp: 50 + player.level * 15, damage: 12 + player.level * 3, exp: 40, color: '#dd4444' },
                    stump: { width: 60, height: 55, hp: 80 + player.level * 20, damage: 15 + player.level * 4, exp: 60, color: '#8B4513' }
                };

                const mt = monsterTypes[type];
                Object.assign(this, mt);
                this.baseExp = this.exp; // Í∏∞Î≥∏ Í≤ΩÌóòÏπò Ï†ÄÏû•
                this.maxHp = this.hp;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = 0;
                this.isDead = false;
                this.deathTimer = 0;
                this.animFrame = 0;
                this.hitFlash = 0;
            }

            update() {
                if (this.isDead) {
                    this.deathTimer++;
                    return this.deathTimer > 30;
                }

                if (this.hitFlash > 0) this.hitFlash--;
                this.animFrame += 0.1;

                if (Math.random() < 0.02) this.vx = (Math.random() - 0.5) * 3;

                const dx = player.x - this.x;
                if (Math.abs(dx) < 300) this.vx += Math.sign(dx) * 0.1;
                this.vx = Math.max(-2, Math.min(2, this.vx));

                this.x += this.vx;
                this.vy += game.gravity;
                this.y += this.vy;

                for (const p of game.platforms) {
                    if (this.y + this.height > p.y && this.y + this.height < p.y + p.height + 10 &&
                        this.x + this.width > p.x && this.x < p.x + p.width && this.vy >= 0) {
                        this.y = p.y - this.height;
                        this.vy = 0;
                    }
                }

                if (this.x < 0) { this.x = 0; this.vx *= -1; }
                if (this.x + this.width > canvas.width) { this.x = canvas.width - this.width; this.vx *= -1; }

                if (player.invincible <= 0 && this.checkCollision(player)) {
                    player.hp -= this.damage;
                    player.invincible = 60;
                    player.vx = Math.sign(player.x - this.x) * 8;
                    player.vy = -5;
                    createDamageText(player.x, player.y, this.damage, '#ff4444');
                    updateUI();
                }

                return false;
            }

            checkCollision(obj) {
                return this.x < obj.x + obj.width && this.x + this.width > obj.x &&
                       this.y < obj.y + obj.height && this.y + this.height > obj.y;
            }

            draw() {
                ctx.save();
                if (this.isDead) ctx.globalAlpha = 1 - this.deathTimer / 30;
                if (this.hitFlash > 0) ctx.filter = 'brightness(2)';

                const bounce = Math.sin(this.animFrame) * 3;

                if (this.type === 'slime') {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.width/2, this.y + this.height - 15 + bounce, this.width/2 - 5, this.height/2 - 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.width/2 - 8, this.y + this.height - 25 + bounce, 8, 6, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'mushroom') {
                    ctx.fillStyle = '#DEB887';
                    ctx.fillRect(this.x + 18, this.y + 28 + bounce, 20, 22);
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.width/2, this.y + 22 + bounce, 28, 22, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(this.x + 18, this.y + 18 + bounce, 6, 0, Math.PI * 2);
                    ctx.arc(this.x + 38, this.y + 20 + bounce, 5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'stump') {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x + 10, this.y + 15 + bounce, 40, 40);
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.arc(this.x + 30, this.y + 35 + bounce, 12, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Îàà
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(this.x + this.width/2 - 8, this.y + this.height/2 + bounce, 3, 0, Math.PI * 2);
                ctx.arc(this.x + this.width/2 + 8, this.y + this.height/2 + bounce, 3, 0, Math.PI * 2);
                ctx.fill();

                // HP Î∞î (Î©îÏù¥ÌîåÏä§ÌÉÄÏùº)
                if (!this.isDead) {
                    // Î™¨Ïä§ÌÑ∞ Ïù¥Î¶Ñ
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    const names = { slime: 'Ïä¨ÎùºÏûÑ', mushroom: 'Î®∏Ïâ¨Î£∏', stump: 'Ïä§ÌÖÄÌîÑ' };
                    ctx.strokeText(names[this.type] || this.type, this.x + this.width/2, this.y - 18);
                    ctx.fillText(names[this.type] || this.type, this.x + this.width/2, this.y - 18);

                    // HP Î∞î Î∞∞Í≤Ω (Í≤ÄÏùÄÏÉâ)
                    ctx.fillStyle = '#000';
                    ctx.fillRect(this.x - 2, this.y - 12, this.width + 4, 8);

                    // HP Î∞î (Îπ®Í∞ÑÏÉâ, Î∂ÄÎìúÎü¨Ïö¥ Ìä∏ÎûúÏßÄÏÖò)
                    const hpPercent = this.hp / this.maxHp;
                    ctx.fillStyle = hpPercent > 0.5 ? '#ff4444' : hpPercent > 0.2 ? '#ff8844' : '#ffaa44';
                    ctx.fillRect(this.x, this.y - 10, hpPercent * this.width, 5);

                    // HP Î∞î ÌÖåÎëêÎ¶¨
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(this.x - 2, this.y - 12, this.width + 4, 8);
                }

                ctx.restore();
            }

            takeDamage(dmg, isCrit = false, isBackstab = false) {
                let finalDmg = Math.floor(dmg * (isCrit ? 1.5 : 1) * (isBackstab ? 2 : 1));
                this.hp -= finalDmg;
                this.hitFlash = 10;

                const color = isBackstab ? '#ff00ff' : (isCrit ? '#ffaa00' : '#ffff00');
                createDamageText(this.x + this.width/2, this.y, finalDmg + (isCrit ? '!' : ''), color, isCrit, isBackstab);
                createParticles(this.x + this.width/2, this.y + this.height/2, this.color, 8);

                if (this.hp <= 0) {
                    this.isDead = true;

                    // ÎπÑÏÑ†Ìòï EXP Ïä§ÏºÄÏùºÎßÅ: Î†àÎ≤® Ï∞®Ïù¥Ïóê Îî∞Î•∏ Î≥¥ÏÉÅ Ï°∞Ï†ï
                    const levelDiff = player.level - this.spawnLevel;
                    let expMultiplier = 1 + (levelDiff * 0.15); // Î†àÎ≤® Ï∞®Ïù¥Îãπ ¬±15%
                    expMultiplier = Math.max(0.3, Math.min(2.0, expMultiplier)); // ÏµúÏÜå 30%, ÏµúÎåÄ 200%
                    const finalExp = Math.floor(this.baseExp * expMultiplier);

                    player.exp += finalExp;
                    player.kills++;
                    checkLevelUp();
                    updateUI();
                }
            }
        }

        // ÏßÅÏóÖ ÏÑ†ÌÉù
        function selectJob(jobId) {
            const job = JOBS[jobId];
            player.job = jobId;
            player.maxHp = job.baseHp;
            player.hp = job.baseHp;
            player.maxMp = job.baseMp;
            player.mp = job.baseMp;
            player.attack = job.baseAttack;
            player.speed = job.speed;
            player.jumpPower = job.jumpPower;
            player.critChance = job.critChance;

            document.getElementById('jobSelect').style.display = 'none';
            document.getElementById('gameUI').style.display = 'block';
            document.getElementById('controlsUI').style.display = 'block';
            document.getElementById('jobName').textContent = job.name;
            document.getElementById('jobIcon').textContent = job.icon;

            // Í≤åÏûÑ ÏãúÏûë 3Ï¥à ÌõÑ Ïª®Ìä∏Î°§ ÏÑ§Î™Ö ÌéòÏù¥ÎìúÏïÑÏõÉ
            setTimeout(() => {
                document.getElementById('controlsUI').classList.add('fade-out');
            }, 3000);

            createSkillBar();
            updateUI();
            game.started = true;
        }

        function createSkillBar() {
            const skillBar = document.getElementById('skillBar');
            const job = JOBS[player.job];
            skillBar.innerHTML = '';

            // Í∏∞Î≥∏ Í≥µÍ≤© Ïä¨Î°Ø
            const basicSlot = document.createElement('div');
            basicSlot.className = 'skill-slot ready';
            basicSlot.id = 'basicAttack';
            const basicIcons = { warrior: '‚öî', thief: 'üó°', archer: 'üèπ' };
            basicSlot.innerHTML = `<div class="key">A</div><div style="font-size: 20px">${basicIcons[player.job] || '‚öî'}</div><div style="font-size: 9px">Í∏∞Î≥∏</div>`;

            // Canvas Ïò§Î≤ÑÎ†àÏù¥ Ï∂îÍ∞Ä
            const basicCanvas = document.createElement('canvas');
            basicCanvas.className = 'cd-overlay';
            basicCanvas.width = 50;
            basicCanvas.height = 50;
            basicSlot.appendChild(basicCanvas);
            skillBar.appendChild(basicSlot);

            job.skills.forEach((skill, i) => {
                const slot = document.createElement('div');
                slot.className = 'skill-slot ready';
                slot.id = `skill${i}`;
                slot.innerHTML = `<div class="key">${skill.key}</div><div style="font-size: 20px">${skill.icon}</div><div style="font-size: 9px">${skill.name.substring(0, 4)}</div>`;

                // Canvas Ïò§Î≤ÑÎ†àÏù¥ Ï∂îÍ∞Ä
                const canvas = document.createElement('canvas');
                canvas.className = 'cd-overlay';
                canvas.width = 50;
                canvas.height = 50;
                slot.appendChild(canvas);
                skillBar.appendChild(slot);
            });
        }

        function updateSkillBar() {
            const job = JOBS[player.job];

            // Í∏∞Î≥∏ Í≥µÍ≤© Ïø®Îã§Ïö¥
            const basicSlot = document.getElementById('basicAttack');
            const basicCanvas = basicSlot.querySelector('canvas.cd-overlay');
            if (player.attackCooldown > 0) {
                basicSlot.className = 'skill-slot';
                drawCooldownArc(basicCanvas, player.attackCooldown, job.basicAttack.cooldown);
            } else {
                basicSlot.className = 'skill-slot ready';
                if (basicCanvas) {
                    const ctx = basicCanvas.getContext('2d');
                    ctx.clearRect(0, 0, 50, 50);
                }
            }

            job.skills.forEach((skill, i) => {
                const slot = document.getElementById(`skill${i}`);
                const canvas = slot.querySelector('canvas.cd-overlay');
                const cooldown = player.skillCooldowns[i];
                if (cooldown > 0) {
                    slot.className = 'skill-slot';
                    let cdDiv = slot.querySelector('.cooldown');
                    if (!cdDiv) {
                        cdDiv = document.createElement('div');
                        cdDiv.className = 'cooldown';
                        slot.appendChild(cdDiv);
                    }
                    cdDiv.textContent = Math.ceil(cooldown / 60);

                    // ÏõêÌòï ÏßÑÌñâÎ∞î Í∑∏Î¶¨Í∏∞
                    drawCooldownArc(canvas, cooldown, skill.cooldown);
                } else {
                    slot.className = 'skill-slot ready';
                    const cdDiv = slot.querySelector('.cooldown');
                    if (cdDiv) cdDiv.remove();

                    // Canvas ÌÅ¥Î¶¨Ïñ¥
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, 50, 50);
                    }
                }
            });
        }

        // ÏõêÌòï Ïø®Îã§Ïö¥ ÏßÑÌñâÎ∞î Í∑∏Î¶¨Í∏∞ (Î©îÏù¥ÌîåÏä§ÌÉÄÏùº)
        function drawCooldownArc(canvas, currentCd, maxCd) {
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const centerX = 25, centerY = 25, radius = 23;

            ctx.clearRect(0, 0, 50, 50);

            // Ïø®Îã§Ïö¥ ÎπÑÏú® Í≥ÑÏÇ∞ (0 = ÏôÑÎ£å, 1 = ÏãúÏûë)
            const progress = currentCd / maxCd;

            // Î∞òÌà¨Î™Ö Í≤ÄÏùÄÏÉâ Ïò§Î≤ÑÎ†àÏù¥ (ÏõêÌòï)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();

            // ÏßÑÌñâÎ∞î (ÏãúÍ≥ÑÎ∞©Ìñ•, 12Ïãú Î∞©Ìñ•Î∂ÄÌÑ∞)
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * progress));
            ctx.stroke();
        }

        function updateBuffBar() {
            const buffBar = document.getElementById('buffBar');
            buffBar.innerHTML = '';
            for (const [buffName, buffData] of Object.entries(player.buffs)) {
                if (buffData.duration > 0) {
                    const buffIcon = document.createElement('div');
                    buffIcon.className = 'buff-icon';
                    const seconds = Math.ceil(buffData.duration / 60);

                    // ÏïÑÏù¥ÏΩò + ÎÇ®ÏùÄ ÏãúÍ∞Ñ ÌÖçÏä§Ìä∏
                    buffIcon.innerHTML = `
                        ${buffData.icon}
                        <div class="buff-time ${seconds <= 10 ? 'warning' : ''} ${seconds <= 3 ? 'critical' : ''}">${seconds}s</div>
                    `;
                    buffIcon.title = buffName;
                    buffBar.appendChild(buffIcon);
                }
            }
        }

        // Í∏∞Î≥∏ Í≥µÍ≤©
        function basicAttack() {
            if (!game.started || player.attackCooldown > 0) return;

            const job = JOBS[player.job];
            const basic = job.basicAttack;
            const attackMultiplier = player.buffs.rage ? player.buffs.rage.attackBonus : 1;
            const damage = player.attack * basic.damage * attackMultiplier;

            player.isAttacking = true;
            player.attackCooldown = basic.cooldown || 20;
            setTimeout(() => player.isAttacking = false, basic.animDuration || 150);

            if (basic.type === 'sword') {
                // Ï†ÑÏÇ¨ Í∏∞Î≥∏ Í≥µÍ≤© - Í≤Ä ÌúòÎëêÎ•¥Í∏∞
                game.effects.push(new Effect('swordSlash', player.x + player.width/2, player.y + player.height/2, player.direction, { maxFrames: 15 }));

                const attackBox = {
                    x: player.direction === 1 ? player.x + player.width : player.x - basic.range,
                    y: player.y - 10,
                    width: basic.range,
                    height: player.height + 20
                };

                for (const monster of game.monsters) {
                    if (!monster.isDead && attackBox.x < monster.x + monster.width && attackBox.x + attackBox.width > monster.x &&
                        attackBox.y < monster.y + monster.height && attackBox.y + attackBox.height > monster.y) {
                        monster.takeDamage(damage, Math.random() * 100 < player.critChance);
                        monster.vx = player.direction * 8;
                        monster.vy = -4;
                    }
                }
            } else if (basic.type === 'dagger') {
                // ÎèÑÏ†Å Í∏∞Î≥∏ Í≥µÍ≤© - Îπ†Î•∏ Îã®Í≤Ä
                game.effects.push(new Effect('daggerSlash', player.x + player.width/2, player.y + player.height/2, player.direction, { maxFrames: 12 }));

                const attackBox = {
                    x: player.direction === 1 ? player.x + player.width : player.x - basic.range,
                    y: player.y - 5,
                    width: basic.range,
                    height: player.height + 10
                };

                for (let h = 0; h < basic.hits; h++) {
                    setTimeout(() => {
                        for (const monster of game.monsters) {
                            if (!monster.isDead && attackBox.x < monster.x + monster.width && attackBox.x + attackBox.width > monster.x &&
                                attackBox.y < monster.y + monster.height && attackBox.y + attackBox.height > monster.y) {
                                monster.takeDamage(damage, Math.random() * 100 < player.critChance);
                            }
                        }
                    }, h * 80);
                }
            } else if (basic.type === 'arrow') {
                // Í∂ÅÏàò Í∏∞Î≥∏ Í≥µÍ≤© - ÌôîÏÇ¥ Î∞úÏÇ¨
                game.effects.push(new Effect('arrowTrail', player.x + player.width/2, player.y + player.height/2, player.direction, { maxFrames: 10 }));

                const piercing = player.buffs.soul && player.buffs.soul.duration > 0;
                game.projectiles.push(new Projectile(
                    player.x + (player.direction === 1 ? player.width : 0),
                    player.y + player.height/2,
                    player.direction,
                    damage,
                    'arrow',
                    piercing
                ));
            }
        }

        // Ïä§ÌÇ¨ ÏÇ¨Ïö©
        function useSkill(skillIndex) {
            if (!game.started || player.skillCooldowns[skillIndex] > 0) return;

            const job = JOBS[player.job];
            const skill = job.skills[skillIndex];
            const slot = document.getElementById(`skill${skillIndex}`);

            // MP Î∂ÄÏ°± Ïãú ÌùîÎì§Î¶º Ïï†ÎãàÎ©îÏù¥ÏÖò
            if (player.mp < skill.mp) {
                if (slot) {
                    slot.classList.add('shake');
                    setTimeout(() => slot.classList.remove('shake'), 300);
                }
                return;
            }

            // Ïä§ÌÇ¨ ÏÇ¨Ïö© Ïãú ÎàåÎ¶º Ïï†ÎãàÎ©îÏù¥ÏÖò
            if (slot) {
                slot.classList.add('press');
                setTimeout(() => slot.classList.remove('press'), 200);
            }

            player.mp -= skill.mp;
            player.skillCooldowns[skillIndex] = skill.cooldown;
            player.isAttacking = true;
            setTimeout(() => player.isAttacking = false, 200);

            const attackMultiplier = player.buffs.rage ? player.buffs.rage.attackBonus : 1;
            const baseDamage = player.attack * skill.damage * attackMultiplier;

            switch (skill.type) {
                case 'powerStrike':
                    performPowerStrike(baseDamage);
                    break;
                case 'slashBlast':
                    performSlashBlast(baseDamage, skill.range);
                    break;
                case 'doubleStab':
                    performDoubleStab(baseDamage, skill.hits);
                    break;
                case 'assassinate':
                    performAssassinate(baseDamage, skill.backstab);
                    break;
                case 'doubleShot':
                    performDoubleShot(baseDamage, skill.arrows, skill.spread);
                    break;
                case 'arrowRain':
                    performArrowRain(baseDamage);
                    break;
            }

            if (skill.buff) {
                player.buffs[skill.buff] = { duration: skill.duration, icon: skill.icon, ...skill };
                const buffEffects = { rage: 'rageActivate', haste: 'hasteActivate', soul: 'soulActivate' };
                if (buffEffects[skill.buff]) {
                    game.effects.push(new Effect(buffEffects[skill.buff], player.x + player.width/2, player.y + player.height/2, player.direction, { maxFrames: 40 }));
                }
            }

            updateUI();
        }

        function performPowerStrike(damage) {
            game.effects.push(new Effect('powerStrike', player.x + player.width/2, player.y + player.height/2, player.direction, { maxFrames: 25 }));

            const attackBox = {
                x: player.direction === 1 ? player.x + player.width - 20 : player.x - 80,
                y: player.y - 20,
                width: 100,
                height: player.height + 40
            };

            for (const monster of game.monsters) {
                if (!monster.isDead && attackBox.x < monster.x + monster.width && attackBox.x + attackBox.width > monster.x &&
                    attackBox.y < monster.y + monster.height && attackBox.y + attackBox.height > monster.y) {
                    monster.takeDamage(damage, Math.random() * 100 < player.critChance);
                    monster.vx = player.direction * 15;
                    monster.vy = -8;
                }
            }
        }

        function performSlashBlast(damage, range) {
            game.effects.push(new Effect('slashBlast', player.x + player.width/2, player.y + player.height/2, player.direction, { maxFrames: 30 }));

            for (const monster of game.monsters) {
                if (!monster.isDead) {
                    const dx = monster.x + monster.width/2 - (player.x + player.width/2);
                    const dy = monster.y + monster.height/2 - (player.y + player.height/2);
                    if (Math.sqrt(dx*dx + dy*dy) < range) {
                        monster.takeDamage(damage, Math.random() * 100 < player.critChance);
                    }
                }
            }
        }

        function performDoubleStab(damage, hits) {
            game.effects.push(new Effect('doubleStab', player.x + player.width/2, player.y + player.height/2, player.direction, { maxFrames: 25, hits: hits }));

            const attackBox = {
                x: player.direction === 1 ? player.x + player.width : player.x - 80,
                y: player.y - 10,
                width: 80,
                height: player.height + 20
            };

            for (let h = 0; h < hits; h++) {
                setTimeout(() => {
                    for (const monster of game.monsters) {
                        if (!monster.isDead && attackBox.x < monster.x + monster.width && attackBox.x + attackBox.width > monster.x &&
                            attackBox.y < monster.y + monster.height && attackBox.y + attackBox.height > monster.y) {
                            monster.takeDamage(damage, Math.random() * 100 < player.critChance);
                        }
                    }
                }, h * 100);
            }
        }

        function performAssassinate(damage, backstab) {
            game.effects.push(new Effect('assassinate', player.x + player.width/2, player.y + player.height/2, player.direction, { maxFrames: 30 }));

            const attackBox = {
                x: player.direction === 1 ? player.x + player.width : player.x - 100,
                y: player.y - 10,
                width: 100,
                height: player.height + 20
            };

            setTimeout(() => {
                for (const monster of game.monsters) {
                    if (!monster.isDead && attackBox.x < monster.x + monster.width && attackBox.x + attackBox.width > monster.x &&
                        attackBox.y < monster.y + monster.height && attackBox.y + attackBox.height > monster.y) {
                        monster.takeDamage(damage, Math.random() * 100 < player.critChance, backstab);
                    }
                }
            }, 200);
        }

        function performDoubleShot(damage, arrows, spread) {
            game.effects.push(new Effect('doubleShot', player.x + player.width/2, player.y + player.height/2, player.direction, { maxFrames: 15 }));

            const piercing = player.buffs.soul && player.buffs.soul.duration > 0;
            for (let i = 0; i < arrows; i++) {
                setTimeout(() => {
                    const offsetY = (i - (arrows-1)/2) * 15;
                    const vy = spread ? (i - (arrows-1)/2) * 3 : 0;
                    game.projectiles.push(new Projectile(
                        player.x + (player.direction === 1 ? player.width : 0),
                        player.y + player.height/2 + offsetY,
                        player.direction, damage, 'arrow', piercing, vy
                    ));
                }, i * 80);
            }
        }

        function performArrowRain(damage) {
            const startX = Math.max(0, player.x - 200);
            const width = 400;

            game.effects.push(new Effect('arrowRain', player.x, player.y, player.direction, {
                maxFrames: 60,
                startX: startX,
                width: width,
                groundY: 480
            }));

            // ÏãúÍ∞ÑÏ∞® Îç∞ÎØ∏ÏßÄ
            for (let i = 0; i < 15; i++) {
                const delay = (i / 15) * 600 + 300;
                const x = startX + (i / 15) * width;
                setTimeout(() => {
                    for (const monster of game.monsters) {
                        if (!monster.isDead && Math.abs(monster.x + monster.width/2 - x) < 40) {
                            monster.takeDamage(damage, Math.random() * 100 < player.critChance);
                        }
                    }
                }, delay);
            }
        }

        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                game.particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8 - 3,
                    life: 30,
                    color,
                    size: Math.random() * 5 + 2
                });
            }
        }

        function createDamageText(x, y, damage, color, isCrit = false, isBackstab = false) {
            // Ï¢åÏö∞ Î∂ÑÏÇ∞ Î∞∞Ïπò (Ïó¨Îü¨ ÎåÄÎØ∏ÏßÄ ÎèôÏãú Î∞úÏÉù Ïãú Í≤πÏπòÏßÄ ÏïäÍ≤å)
            const offsetX = (Math.random() - 0.5) * 30;
            game.damageTexts.push({ x: x + offsetX, y, damage, color, life: 60, vy: -2, isCrit, isBackstab });
        }

        function checkLevelUp() {
            while (player.exp >= player.expToLevel) {
                player.exp -= player.expToLevel;
                player.level++;

                const job = JOBS[player.job];
                player.maxHp += job.hpPerLevel;
                player.hp = player.maxHp;
                player.maxMp += job.mpPerLevel;
                player.mp = player.maxMp;
                player.attack += job.attackPerLevel;
                player.critChance += 0.5; // Î†àÎ≤®Îãπ ÌÅ¨Î¶¨Ìã∞Ïª¨ ÌôïÎ•† +0.5%
                player.expToLevel = Math.floor(player.expToLevel * 1.5);

                // Î†àÎ≤®ÏóÖ ÌÖçÏä§Ìä∏ (Î†àÎ≤® Ïà´Ïûê Ìè¨Ìï®)
                const levelUpText = document.getElementById('levelUpText');
                levelUpText.textContent = `LEVEL UP! Lv.${player.level}`;
                levelUpText.style.display = 'block';
                levelUpText.style.animation = 'none';
                levelUpText.offsetHeight;
                levelUpText.style.animation = 'levelUp 2s ease-out forwards';
                setTimeout(() => levelUpText.style.display = 'none', 2000);

                // Ïä§ÌÉØ Ï¶ùÍ∞ÄÎ∂Ñ ÌëúÏãú
                const statGainText = document.getElementById('statGainText');
                statGainText.textContent = `HP +${job.hpPerLevel} | MP +${job.mpPerLevel} | ATK +${job.attackPerLevel} | CRIT +0.5%`;
                statGainText.style.display = 'block';
                statGainText.style.animation = 'none';
                statGainText.offsetHeight;
                statGainText.style.animation = 'levelUp 1.5s ease-out forwards';
                setTimeout(() => statGainText.style.display = 'none', 1500);

                for (let i = 0; i < 50; i++) {
                    game.particles.push({
                        x: player.x + player.width/2 + (Math.random() - 0.5) * 100,
                        y: player.y + player.height/2 + (Math.random() - 0.5) * 100,
                        vx: (Math.random() - 0.5) * 4,
                        vy: -Math.random() * 5,
                        life: 60,
                        color: '#ffff00',
                        size: Math.random() * 6 + 3
                    });
                }
            }
        }

        function updateUI() {
            if (!game.started) return;
            document.getElementById('level').textContent = player.level;

            // HP Î∞î ÏóÖÎç∞Ïù¥Ìä∏ Î∞è ÏúÑÌóò Íµ¨Í∞Ñ(‚â§30%) ÍπúÎπ° Ìö®Í≥º
            const hpBar = document.getElementById('hpBar');
            const hpPercent = player.hp / player.maxHp * 100;
            hpBar.style.width = hpPercent + '%';
            if (hpPercent <= 30) {
                hpBar.classList.add('hp-fill-danger');
            } else {
                hpBar.classList.remove('hp-fill-danger');
            }

            document.getElementById('hpText').textContent = `${Math.max(0, Math.floor(player.hp))}/${player.maxHp}`;
            document.getElementById('mpBar').style.width = (player.mp / player.maxMp * 100) + '%';
            document.getElementById('mpText').textContent = `${Math.max(0, Math.floor(player.mp))}/${player.maxMp}`;
            document.getElementById('expBar').style.width = (player.exp / player.expToLevel * 100) + '%';
            document.getElementById('expText').textContent = `${player.exp}/${player.expToLevel}`;
            document.getElementById('attack').textContent = Math.floor(player.attack * (player.buffs.rage ? player.buffs.rage.attackBonus : 1));
            document.getElementById('crit').textContent = player.critChance;
            document.getElementById('kills').textContent = player.kills;
        }

        function spawnMonster() {
            const now = Date.now();
            if (now - game.lastMonsterSpawn > game.monsterSpawnInterval && game.monsters.length < 10) {
                const x = Math.random() * (canvas.width - 100) + 50;
                const rand = Math.random();
                let type = 'slime';
                if (rand > 0.7 && player.level >= 3) type = 'stump';
                else if (rand > 0.4) type = 'mushroom';
                game.monsters.push(new Monster(x, 50, type));
                game.lastMonsterSpawn = now;
                game.monsterSpawnInterval = Math.max(1000, 2500 - player.level * 100);
            }
        }

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a1a3e');
            gradient.addColorStop(0.5, '#2a2a5e');
            gradient.addColorStop(1, '#3a3a7e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 50; i++) {
                const x = (i * 73) % canvas.width;
                const y = (i * 37) % (canvas.height - 200);
                ctx.globalAlpha = 0.3 + Math.sin(Date.now() / 1000 + i) * 0.3;
                ctx.beginPath();
                ctx.arc(x, y, (i % 3) + 1, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            for (const p of game.platforms) {
                const platGradient = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.height);
                platGradient.addColorStop(0, '#5a8a5a');
                platGradient.addColorStop(1, '#3a6a3a');
                ctx.fillStyle = platGradient;
                ctx.fillRect(p.x, p.y, p.width, p.height);
                ctx.fillStyle = '#7aba7a';
                ctx.fillRect(p.x, p.y, p.width, 5);
                ctx.fillStyle = '#4a9a4a';
                for (let i = 0; i < p.width; i += 10) {
                    ctx.beginPath();
                    ctx.moveTo(p.x + i, p.y);
                    ctx.lineTo(p.x + i + 5, p.y - 8);
                    ctx.lineTo(p.x + i + 10, p.y);
                    ctx.fill();
                }
            }
        }

        function drawPlayer() {
            ctx.save();
            if (player.invincible > 0 && Math.floor(player.invincible / 5) % 2 === 0) ctx.globalAlpha = 0.5;

            const px = player.x, py = player.y, dir = player.direction;
            const job = JOBS[player.job];

            ctx.translate(px + player.width/2, py);
            ctx.scale(dir, 1);
            ctx.translate(-(px + player.width/2), -py);

            // Î≤ÑÌîÑ Ïù¥ÌéôÌä∏
            if (player.buffs.rage && player.buffs.rage.duration > 0) {
                ctx.fillStyle = 'rgba(255, 100, 50, 0.3)';
                ctx.beginPath();
                ctx.arc(px + player.width/2, py + player.height/2, 40 + Math.sin(Date.now()/100) * 5, 0, Math.PI * 2);
                ctx.fill();
            }
            if (player.buffs.haste && player.buffs.haste.duration > 0) {
                ctx.fillStyle = 'rgba(170, 68, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(px + player.width/2, py + player.height/2, 35, 0, Math.PI * 2);
                ctx.fill();
            }
            if (player.buffs.soul && player.buffs.soul.duration > 0) {
                ctx.fillStyle = 'rgba(68, 255, 102, 0.3)';
                ctx.beginPath();
                ctx.arc(px + player.width/2, py + player.height/2, 35, 0, Math.PI * 2);
                ctx.fill();
            }

            const bodyColor = job ? job.color : '#4488ff';

            // Î™∏ÌÜµ
            ctx.fillStyle = bodyColor;
            ctx.fillRect(px + 8, py + 20, 24, 30);

            // Î®∏Î¶¨
            ctx.fillStyle = '#ffcc99';
            ctx.beginPath();
            ctx.arc(px + player.width/2, py + 15, 15, 0, Math.PI * 2);
            ctx.fill();

            // ÏßÅÏóÖÎ≥Ñ Ìó§Ïñ¥/Î™®Ïûê
            if (player.job === 'warrior') {
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(px + player.width/2, py + 8, 14, Math.PI, Math.PI * 2);
                ctx.fill();
            } else if (player.job === 'thief') {
                ctx.fillStyle = '#442266';
                ctx.beginPath();
                ctx.moveTo(px + 5, py + 15);
                ctx.lineTo(px + 20, py - 5);
                ctx.lineTo(px + 35, py + 15);
                ctx.fill();
            } else if (player.job === 'archer') {
                ctx.fillStyle = '#228844';
                ctx.beginPath();
                ctx.arc(px + player.width/2, py + 10, 13, Math.PI, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#116633';
                ctx.beginPath();
                ctx.moveTo(px + 10, py + 5);
                ctx.lineTo(px + 20, py - 10);
                ctx.lineTo(px + 30, py + 5);
                ctx.fill();
            }

            // Îàà
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(px + player.width/2 + 5, py + 15, 2, 0, Math.PI * 2);
            ctx.fill();

            // Îã§Î¶¨
            ctx.fillStyle = '#333';
            ctx.fillRect(px + 10, py + 50, 8, 10);
            ctx.fillRect(px + 22, py + 50, 8, 10);

            // Î¨¥Í∏∞
            if (player.job === 'warrior') {
                ctx.fillStyle = '#888';
                ctx.fillRect(px + 35, py + 25, 8, 35);
                ctx.fillStyle = '#ffcc00';
                ctx.fillRect(px + 33, py + 22, 12, 8);
            } else if (player.job === 'thief') {
                ctx.fillStyle = '#666';
                ctx.beginPath();
                ctx.moveTo(px + 40, py + 30);
                ctx.lineTo(px + 55, py + 25);
                ctx.lineTo(px + 55, py + 35);
                ctx.fill();
            } else if (player.job === 'archer') {
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(px + 35, py + 30, 20, -Math.PI/2, Math.PI/2);
                ctx.stroke();
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(px + 35, py + 10);
                ctx.lineTo(px + 35, py + 50);
                ctx.stroke();
            }

            ctx.restore();
        }

        function gameLoop() {
            if (!game.started) {
                requestAnimationFrame(gameLoop);
                return;
            }

            // MP ÏûêÎèô ÌöåÎ≥µ
            if (player.mp < player.maxMp) player.mp += 0.05;

            // Ïø®Îã§Ïö¥
            if (player.attackCooldown > 0) player.attackCooldown--;
            for (let i = 0; i < player.skillCooldowns.length; i++) {
                if (player.skillCooldowns[i] > 0) player.skillCooldowns[i]--;
            }

            // Î≤ÑÌîÑ ÏóÖÎç∞Ïù¥Ìä∏
            for (const [buffName, buffData] of Object.entries(player.buffs)) {
                if (buffData.duration > 0) {
                    buffData.duration--;
                    if (buffData.duration <= 0) delete player.buffs[buffName];
                }
            }
            updateBuffBar();
            updateSkillBar();

            // Ïù¥Îèô
            let currentSpeed = player.speed * (player.buffs.haste ? player.buffs.haste.speedBonus : 1);
            if (game.keys['ArrowLeft']) {
                player.vx = -currentSpeed;
                player.direction = -1;
            } else if (game.keys['ArrowRight'] || game.keys['KeyD']) {
                player.vx = currentSpeed;
                player.direction = 1;
            } else {
                player.vx *= 0.8;
            }

            if ((game.keys['ArrowUp'] || game.keys['Space'] || game.keys['KeyW']) && !player.isJumping) {
                player.vy = player.jumpPower;
                player.isJumping = true;
            }

            player.x += player.vx;
            player.vy += game.gravity;
            player.y += player.vy;

            // ÌîåÎû´Ìèº Ï∂©Îèå
            player.isJumping = true;
            for (const p of game.platforms) {
                if (player.y + player.height > p.y && player.y + player.height < p.y + p.height + 10 &&
                    player.x + player.width > p.x && player.x < p.x + p.width && player.vy >= 0) {
                    player.y = p.y - player.height;
                    player.vy = 0;
                    player.isJumping = false;
                }
            }

            // Í≤ΩÍ≥Ñ
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            if (player.y > canvas.height) {
                player.y = 100;
                player.hp -= 20;
                updateUI();
            }

            if (player.invincible > 0) player.invincible--;

            // ÏóÖÎç∞Ïù¥Ìä∏
            spawnMonster();
            game.monsters = game.monsters.filter(m => !m.update());
            game.projectiles = game.projectiles.filter(p => !p.update());
            game.effects = game.effects.filter(e => !e.update());

            game.particles = game.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life--;
                return p.life > 0;
            });

            game.damageTexts = game.damageTexts.filter(t => {
                t.y += t.vy;
                t.life--;
                return t.life > 0;
            });

            // ÏÇ¨Îßù
            if (player.hp <= 0) {
                player.hp = player.maxHp;
                player.mp = player.maxMp;
                player.x = 100;
                player.y = 400;
                player.exp = Math.floor(player.exp / 2);
                updateUI();
            }

            // Î†åÎçîÎßÅ
            drawBackground();
            for (const monster of game.monsters) monster.draw();
            drawPlayer();
            for (const proj of game.projectiles) proj.draw();
            for (const effect of game.effects) effect.draw();

            // ÌååÌã∞ÌÅ¥
            for (const p of game.particles) {
                ctx.globalAlpha = p.life / 30;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Îç∞ÎØ∏ÏßÄ ÌÖçÏä§Ìä∏
            for (const t of game.damageTexts) {
                ctx.globalAlpha = t.life / 60;
                ctx.fillStyle = t.color;

                // ÌÅ¨Î¶¨Ìã∞Ïª¨: Ìè∞Ìä∏ ÌÅ¨Í∏∞ 1.5Î∞∞, Î∞±Ïä§ÌÉ≠: Î≥ºÎìúÏ≤¥ Í∞ïÌôî
                let fontSize = 20;
                let fontWeight = 'bold';
                if (t.isCrit) fontSize = 30; // ÌÅ¨Î¶¨Ìã∞Ïª¨ÏùÄ 1.5Î∞∞ ÌÅ¨Í∏∞
                if (t.isBackstab) fontWeight = '900'; // Î∞±Ïä§ÌÉ≠ÏùÄ Îçî ÍµµÍ≤å

                ctx.font = `${fontWeight} ${fontSize}px Arial`;
                ctx.textAlign = 'center';

                // Ïô∏Í≥ΩÏÑ† (Î©îÏù¥ÌîåÏä§ÌÉÄÏùº)
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(t.damage, t.x, t.y);

                // ÌÖçÏä§Ìä∏
                ctx.fillText(t.damage, t.x, t.y);
            }
            ctx.globalAlpha = 1;

            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (e) => {
            game.keys[e.code] = true;
            if (e.code === 'KeyA' && !e.repeat) basicAttack();
            if (e.code === 'KeyZ') useSkill(0);
            if (e.code === 'KeyX') useSkill(1);
            if (e.code === 'KeyC') useSkill(2);
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
        });

        document.addEventListener('keyup', (e) => {
            game.keys[e.code] = false;
        });

        gameLoop();
    </script>
</body>
</html>
