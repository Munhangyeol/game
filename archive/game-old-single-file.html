<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapleQuest RPG</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', sans-serif;
        }
        .game-container { position: relative; }
        canvas {
            border: 4px solid #4a4a6a;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(100, 100, 255, 0.3);
        }
        .ui-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        .stat-bar {
            width: 200px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin: 5px 0;
            overflow: hidden;
            border: 2px solid #555;
        }
        .hp-fill { height: 100%; background: linear-gradient(90deg, #ff4444, #ff6666); transition: width 0.3s; }
        .mp-fill { height: 100%; background: linear-gradient(90deg, #4444ff, #6666ff); transition: width 0.3s; }
        .exp-fill { height: 100%; background: linear-gradient(90deg, #44ff44, #66ff66); transition: width 0.3s; }
        .controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #aaa;
            font-size: 12px;
            transition: opacity 1s ease-out;
            opacity: 1;
        }
        .controls.fade-out {
            opacity: 0;
        }
        .level-up {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffff00;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 20px #ffff00;
            animation: levelUp 2s ease-out forwards;
            pointer-events: none;
            display: none;
            text-align: center;
        }
        .stat-gain {
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translate(-50%, 0);
            color: #44ff44;
            font-size: 20px;
            text-shadow: 0 0 10px #44ff44;
            pointer-events: none;
            display: none;
            animation: levelUp 1.5s ease-out forwards;
        }
        @keyframes levelUp {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -100%) scale(1); }
        }
        @keyframes hpPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .hp-fill-danger {
            animation: hpPulse 0.8s ease-in-out infinite;
        }
        .job-select {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            border-radius: 8px;
        }
        .job-select h1 { color: #ffcc00; font-size: 36px; margin-bottom: 10px; text-shadow: 0 0 20px #ffcc00; }
        .job-select p { color: #aaa; margin-bottom: 30px; }
        .job-cards { display: flex; gap: 20px; }
        .job-card {
            width: 200px;
            padding: 20px;
            background: linear-gradient(135deg, #2a2a4a, #1a1a3a);
            border: 3px solid #4a4a6a;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        .job-card:hover {
            transform: translateY(-10px);
            border-color: #ffcc00;
            box-shadow: 0 10px 30px rgba(255, 204, 0, 0.3);
        }
        .job-card h2 { color: #fff; margin-bottom: 10px; }
        .job-card .job-icon { font-size: 60px; margin: 15px 0; }
        .job-card .job-stats { color: #aaa; font-size: 12px; text-align: left; margin-top: 15px; }
        .job-card .job-stats div { margin: 5px 0; }
        .job-card.warrior { border-top: 4px solid #ff6644; }
        .job-card.thief { border-top: 4px solid #aa44ff; }
        .job-card.archer { border-top: 4px solid #44ff66; }
        .job-card.warrior:hover { border-color: #ff6644; box-shadow: 0 10px 30px rgba(255, 102, 68, 0.3); }
        .job-card.thief:hover { border-color: #aa44ff; box-shadow: 0 10px 30px rgba(170, 68, 255, 0.3); }
        .job-card.archer:hover { border-color: #44ff66; box-shadow: 0 10px 30px rgba(68, 255, 102, 0.3); }
        .skill-bar {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        .skill-slot {
            width: 50px; height: 50px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #555;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 10px;
            position: relative;
        }
        .skill-slot .key {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            padding: 1px 5px;
            border-radius: 3px;
            font-size: 9px;
        }
        .skill-slot .cooldown {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            font-weight: bold;
            border-radius: 6px;
            pointer-events: none;
            z-index: 10;
        }
        .skill-slot canvas.cd-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        .skill-slot.ready {
            border-color: #44ff44;
            box-shadow: 0 0 10px rgba(68, 255, 68, 0.5);
            animation: skillReady 0.5s ease-out;
        }
        @keyframes skillReady {
            0% { box-shadow: 0 0 10px rgba(68, 255, 68, 0.5); }
            50% { box-shadow: 0 0 20px rgba(68, 255, 68, 1); }
            100% { box-shadow: 0 0 10px rgba(68, 255, 68, 0.5); }
        }
        @keyframes skillPress {
            0% { transform: scale(1); }
            50% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }
        @keyframes skillShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }
        .skill-slot.press { animation: skillPress 0.2s ease-out; }
        .skill-slot.shake { animation: skillShake 0.3s ease-out; }
        .buff-bar {
            position: absolute;
            top: 160px;
            left: 10px;
            display: flex;
            gap: 5px;
        }
        .buff-icon {
            width: 40px; height: 45px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #ffcc00;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            position: relative;
        }
        .buff-time {
            font-size: 9px;
            color: #fff;
            font-weight: bold;
            margin-top: 2px;
        }
        .buff-time.warning {
            color: #ffaa00;
        }
        .buff-time.critical {
            color: #ff4444;
            animation: buffBlink 0.5s infinite;
        }
        @keyframes buffBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="1000" height="600"></canvas>

        <div class="job-select" id="jobSelect">
            <h1>ì§ì—…ì„ ì„ íƒí•˜ì„¸ìš”</h1>
            <p>ê° ì§ì—…ì€ ê³ ìœ í•œ ìŠ¤íƒ¯ê³¼ ìŠ¤í‚¬ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤</p>
            <div class="job-cards">
                <div class="job-card warrior" onclick="selectJob('warrior')">
                    <h2 style="color: #ff6644">ì „ì‚¬</h2>
                    <div class="job-icon">âš”ï¸</div>
                    <div class="job-stats">
                        <div>â¤ï¸ HP: â˜…â˜…â˜…â˜…â˜…</div>
                        <div>âš¡ ì†ë„: â˜…â˜…â˜†â˜†â˜†</div>
                        <div>ğŸ’ª ê³µê²©ë ¥: â˜…â˜…â˜…â˜…â˜†</div>
                        <div style="color: #ff6644; margin-top: 10px;">
                            <b>ìŠ¤í‚¬:</b><br>
                            [A] ê¸°ë³¸ê³µê²© - ê²€ íœ˜ë‘ë¥´ê¸°<br>
                            [Z] ğŸ’¥ íŒŒì›Œ ìŠ¤íŠ¸ë¼ì´í¬<br>
                            [X] ğŸŒ€ ìŠ¬ë˜ì‹œ ë¸”ë˜ìŠ¤íŠ¸<br>
                            [C] ğŸ˜¤ ë ˆì´ì§€ (ë²„í”„)
                        </div>
                    </div>
                </div>
                <div class="job-card thief" onclick="selectJob('thief')">
                    <h2 style="color: #aa44ff">ë„ì </h2>
                    <div class="job-icon">ğŸ—¡ï¸</div>
                    <div class="job-stats">
                        <div>â¤ï¸ HP: â˜…â˜…â˜…â˜†â˜†</div>
                        <div>âš¡ ì†ë„: â˜…â˜…â˜…â˜…â˜…</div>
                        <div>ğŸ’ª ê³µê²©ë ¥: â˜…â˜…â˜…â˜†â˜†</div>
                        <div style="color: #aa44ff; margin-top: 10px;">
                            <b>ìŠ¤í‚¬:</b><br>
                            [A] ê¸°ë³¸ê³µê²© - ë‹¨ê²€ ë‚œë¬´<br>
                            [Z] âš¡ ì‚¼ì¤‘ ìŠ¤íƒ­<br>
                            [X] ğŸ’€ ì–´ìŒ”ì‹œë„¤ì´íŠ¸<br>
                            [C] ğŸ’¨ í—¤ì´ìŠ¤íŠ¸ (ë²„í”„)
                        </div>
                    </div>
                </div>
                <div class="job-card archer" onclick="selectJob('archer')">
                    <h2 style="color: #44ff66">ê¶ìˆ˜</h2>
                    <div class="job-icon">ğŸ¹</div>
                    <div class="job-stats">
                        <div>â¤ï¸ HP: â˜…â˜…â˜†â˜†â˜†</div>
                        <div>âš¡ ì†ë„: â˜…â˜…â˜…â˜†â˜†</div>
                        <div>ğŸ’ª ê³µê²©ë ¥: â˜…â˜…â˜…â˜…â˜…</div>
                        <div style="color: #44ff66; margin-top: 10px;">
                            <b>ìŠ¤í‚¬:</b><br>
                            [A] ê¸°ë³¸ê³µê²© - í™”ì‚´ ë°œì‚¬<br>
                            [Z] â¹ ë”ë¸” ìƒ·<br>
                            [X] ğŸŒ§ï¸ ì• ë¡œìš° ë ˆì¸<br>
                            [C] âœ¨ ì†Œìš¸ ì• ë¡œìš° (ë²„í”„)
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="ui-overlay" id="gameUI" style="display: none;">
            <div><span id="jobIcon">âš”ï¸</span> Lv. <span id="level">1</span> <span id="jobName">ì „ì‚¬</span></div>
            <div class="stat-bar"><div class="hp-fill" id="hpBar" style="width: 100%"></div></div>
            <div style="font-size: 12px">HP: <span id="hpText">100/100</span></div>
            <div class="stat-bar"><div class="mp-fill" id="mpBar" style="width: 100%"></div></div>
            <div style="font-size: 12px">MP: <span id="mpText">50/50</span></div>
            <div class="stat-bar"><div class="exp-fill" id="expBar" style="width: 0%"></div></div>
            <div style="font-size: 12px">EXP: <span id="expText">0/100</span></div>
            <div style="margin-top: 10px">âš”ï¸ ê³µê²©ë ¥: <span id="attack">10</span></div>
            <div>ğŸ’¥ í¬ë¦¬í‹°ì»¬: <span id="crit">10</span>%</div>
            <div>ğŸ’€ ì²˜ì¹˜: <span id="kills">0</span></div>
        </div>

        <div class="buff-bar" id="buffBar"></div>
        <div class="skill-bar" id="skillBar"></div>
        <div class="controls" id="controlsUI" style="display: none;">
            [â†â†’] ì´ë™ | [â†‘/Space] ì í”„ | [A] ê¸°ë³¸ê³µê²© | [Z][X][C] ìŠ¤í‚¬
        </div>
        <div class="level-up" id="levelUpText">LEVEL UP!</div>
        <div class="stat-gain" id="statGainText"></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ì§ì—… ì •ì˜
        const JOBS = {
            warrior: {
                name: 'ì „ì‚¬',
                icon: 'âš”ï¸',
                color: '#ff6644',
                baseHp: 150,
                baseMp: 30,
                baseAttack: 15,
                speed: 4,
                jumpPower: -13,
                critChance: 10,
                hpPerLevel: 30,
                mpPerLevel: 5,
                attackPerLevel: 7,
                promotionBonus: [
                    { level: 10, hp: 100, mp: 20 },  // ì´ˆë³€ì§ (ê¸°ì‚¬)
                    { level: 30, hp: 200, mp: 40 },  // ì¬ë³€ì§ (ë‹¤í¬ë‚˜ì´íŠ¸)
                    { level: 70, hp: 400, mp: 80 }   // ìµœì¢…ë³€ì§ (íˆì–´ë¡œ)
                ],
                basicAttack: { damage: 1.4, range: 75, type: 'sword', cooldown: 28, animDuration: 200 },
                skills: [
                    { name: 'íŒŒì›Œ ìŠ¤íŠ¸ë¼ì´í¬', key: 'Z', mp: 5, cooldown: 30, damage: 2.8, type: 'powerStrike', knockback: true, icon: 'ğŸ’¥' },
                    { name: 'ìŠ¬ë˜ì‹œ ë¸”ë˜ìŠ¤íŠ¸', key: 'X', mp: 10, cooldown: 90, damage: 1.5, type: 'slashBlast', range: 150, icon: 'ğŸŒ€' },
                    { name: 'ë ˆì´ì§€', key: 'C', mp: 15, cooldown: 600, duration: 600, buff: 'rage', attackBonus: 1.5, icon: 'ğŸ˜¤' }
                ]
            },
            thief: {
                name: 'ë„ì ',
                icon: 'ğŸ—¡ï¸',
                color: '#aa44ff',
                baseHp: 100,
                baseMp: 50,
                baseAttack: 12,
                speed: 7,
                jumpPower: -14,
                critChance: 25,
                hpPerLevel: 20,
                mpPerLevel: 8,
                attackPerLevel: 5,
                promotionBonus: [
                    { level: 10, hp: 80, mp: 30 },   // ì´ˆë³€ì§ (ë¡œê·¸)
                    { level: 30, hp: 150, mp: 60 },  // ì¬ë³€ì§ (ì–´ìŒ”ì‹ )
                    { level: 70, hp: 300, mp: 120 }  // ìµœì¢…ë³€ì§ (ë‚˜ì´íŠ¸ë¡œë“œ)
                ],
                basicAttack: { damage: 0.4, range: 50, type: 'dagger', hits: 2, cooldown: 10, animDuration: 60 },
                skills: [
                    { name: 'ì‚¼ì¤‘ ìŠ¤íƒ­', key: 'Z', mp: 5, cooldown: 35, damage: 1.4, hits: 3, type: 'doubleStab', icon: 'âš¡' },
                    { name: 'ì–´ìŒ”ì‹œë„¤ì´íŠ¸', key: 'X', mp: 12, cooldown: 120, damage: 4.5, type: 'assassinate', backstab: true, icon: 'ğŸ’€' },
                    { name: 'í—¤ì´ìŠ¤íŠ¸', key: 'C', mp: 10, cooldown: 480, duration: 600, buff: 'haste', speedBonus: 1.5, icon: 'ğŸ’¨' }
                ]
            },
            archer: {
                name: 'ê¶ìˆ˜',
                icon: 'ğŸ¹',
                color: '#44ff66',
                baseHp: 80,
                baseMp: 40,
                baseAttack: 18,
                speed: 5,
                jumpPower: -13,
                critChance: 20,
                hpPerLevel: 15,
                mpPerLevel: 7,
                attackPerLevel: 8,
                promotionBonus: [
                    { level: 10, hp: 70, mp: 25 },   // ì´ˆë³€ì§ (í—Œí„°)
                    { level: 30, hp: 130, mp: 50 },  // ì¬ë³€ì§ (ë ˆì¸ì €)
                    { level: 70, hp: 250, mp: 100 }  // ìµœì¢…ë³€ì§ (ë³´ìš°ë§ˆìŠ¤í„°)
                ],
                basicAttack: { damage: 1.0, type: 'arrow', cooldown: 18, animDuration: 100 },
                skills: [
                    { name: 'ë”ë¸” ìƒ·', key: 'Z', mp: 3, cooldown: 20, damage: 1.8, arrows: 2, type: 'doubleShot', spread: true, icon: 'â¹' },
                    { name: 'ì• ë¡œìš° ë ˆì¸', key: 'X', mp: 15, cooldown: 150, damage: 1.0, type: 'arrowRain', icon: 'ğŸŒ§ï¸' },
                    { name: 'ì†Œìš¸ ì• ë¡œìš°', key: 'C', mp: 8, cooldown: 420, duration: 600, buff: 'soul', piercing: true, icon: 'âœ¨' }
                ]
            }
        };

        // ê²Œì„ ìƒíƒœ
        const game = {
            started: false,
            gravity: 0.6,
            platforms: [
                { x: 0, y: 500, width: 1000, height: 100 },
                { x: 150, y: 400, width: 150, height: 20 },
                { x: 420, y: 350, width: 160, height: 20 },
                { x: 700, y: 400, width: 150, height: 20 },
                { x: 50, y: 280, width: 120, height: 20 },
                { x: 550, y: 250, width: 120, height: 20 },
                { x: 820, y: 280, width: 120, height: 20 },
            ],
            monsters: [],
            particles: [],
            damageTexts: [],
            projectiles: [],
            effects: [],
            coins: [],
            skillNames: [],
            keys: {},
            lastMonsterSpawn: 0,
            monsterSpawnInterval: 2500,
            combo: 0,
            lastHitTime: 0,
            screenShake: { x: 0, y: 0, frames: 0 },
            hitStop: 0,
            meso: 0,
        };

        // í”Œë ˆì´ì–´
        const player = {
            x: 100, y: 400,
            width: 40, height: 60,
            vx: 0, vy: 0,
            speed: 5,
            jumpPower: -14,
            isJumping: false,
            direction: 1,
            isAttacking: false,
            attackCooldown: 0,
            hp: 100, maxHp: 100,
            mp: 50, maxMp: 50,
            exp: 0, expToLevel: 100,
            level: 1,
            attack: 10,
            critChance: 10,
            kills: 0,
            invincible: 0,
            job: null,
            skillCooldowns: [0, 0, 0],
            buffs: {},
            trail: [],
        };

        // ì´í™íŠ¸ í´ë˜ìŠ¤
        class Effect {
            constructor(type, x, y, direction, data = {}) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.direction = direction;
                this.frame = 0;
                this.maxFrames = data.maxFrames || 20;
                this.data = data;
            }

            update() {
                this.frame++;
                return this.frame >= this.maxFrames;
            }

            draw() {
                ctx.save();
                const progress = this.frame / this.maxFrames;

                switch(this.type) {
                    case 'swordSlash':
                        this.drawSwordSlash(progress);
                        break;
                    case 'powerStrike':
                        this.drawPowerStrike(progress);
                        break;
                    case 'slashBlast':
                        this.drawSlashBlast(progress);
                        break;
                    case 'daggerSlash':
                        this.drawDaggerSlash(progress);
                        break;
                    case 'doubleStab':
                        this.drawDoubleStab(progress);
                        break;
                    case 'assassinate':
                        this.drawAssassinate(progress);
                        break;
                    case 'arrowTrail':
                        this.drawArrowTrail(progress);
                        break;
                    case 'doubleShot':
                        this.drawDoubleShot(progress);
                        break;
                    case 'arrowRain':
                        this.drawArrowRain(progress);
                        break;
                    case 'rageActivate':
                        this.drawRageActivate(progress);
                        break;
                    case 'hasteActivate':
                        this.drawHasteActivate(progress);
                        break;
                    case 'soulActivate':
                        this.drawSoulActivate(progress);
                        break;
                    case 'critBurst':
                        this.drawCritBurst(progress);
                        break;
                    case 'levelUpPillar':
                        this.drawLevelUpPillar(progress);
                        break;
                }

                ctx.restore();
            }

            drawSwordSlash(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = '#ffaa44';
                ctx.lineWidth = 4 - progress * 3;
                ctx.lineCap = 'round';

                const startAngle = this.direction === 1 ? -Math.PI/3 : Math.PI + Math.PI/3;
                const endAngle = this.direction === 1 ? Math.PI/3 : Math.PI - Math.PI/3;
                const currentAngle = startAngle + (endAngle - startAngle) * Math.min(1, progress * 2);

                ctx.beginPath();
                ctx.arc(this.x, this.y, 50 + progress * 20, startAngle, currentAngle);
                ctx.stroke();

                // ê²€ ê¶¤ì  ë¹›
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 45 + progress * 20, startAngle, currentAngle);
                ctx.stroke();
            }

            drawPowerStrike(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                // ê°•ë ¥í•œ ì¶©ê²©íŒŒ
                const radius = 30 + progress * 80;
                ctx.strokeStyle = '#ff6644';
                ctx.lineWidth = 8 - progress * 6;
                ctx.beginPath();
                ctx.arc(this.x + this.direction * 40, this.y, radius, 0, Math.PI * 2);
                ctx.stroke();

                // ë‚´ë¶€ í­ë°œ
                ctx.fillStyle = `rgba(255, 150, 50, ${alpha * 0.5})`;
                ctx.beginPath();
                ctx.arc(this.x + this.direction * 40, this.y, radius * 0.6, 0, Math.PI * 2);
                ctx.fill();

                // ìŠ¤íŒŒí¬
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + progress * 2;
                    const dist = radius * 0.8;
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(
                        this.x + this.direction * 40 + Math.cos(angle) * dist,
                        this.y + Math.sin(angle) * dist,
                        4 - progress * 3, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }

            drawSlashBlast(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                // ë‹¤ì¤‘ ì›í˜• ìŠ¬ë˜ì‹œ
                for (let i = 0; i < 3; i++) {
                    const delay = i * 0.15;
                    const p = Math.max(0, progress - delay) / (1 - delay);
                    if (p > 0 && p < 1) {
                        const radius = 50 + p * 100;
                        ctx.strokeStyle = i === 0 ? '#ff6644' : (i === 1 ? '#ff9966' : '#ffcc88');
                        ctx.lineWidth = 6 - p * 5;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                // ìŠ¬ë˜ì‹œ ë¼ì¸ë“¤
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const len = 60 + progress * 80;
                    ctx.strokeStyle = '#ffaa44';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(this.x + Math.cos(angle) * 20, this.y + Math.sin(angle) * 20);
                    ctx.lineTo(this.x + Math.cos(angle) * len, this.y + Math.sin(angle) * len);
                    ctx.stroke();
                }
            }

            drawDaggerSlash(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                // ë¹ ë¥¸ ë‹¨ê²€ ê¶¤ì  (2ê°œ)
                for (let i = 0; i < 2; i++) {
                    const offset = i * 0.3;
                    const p = Math.max(0, Math.min(1, (progress - offset) * 2));

                    ctx.strokeStyle = i === 0 ? '#aa44ff' : '#dd88ff';
                    ctx.lineWidth = 3 - p * 2;
                    ctx.lineCap = 'round';

                    const startX = this.x + this.direction * 10;
                    const endX = this.x + this.direction * (40 + p * 20);
                    const offsetY = (i - 0.5) * 20;

                    ctx.beginPath();
                    ctx.moveTo(startX, this.y + offsetY - 10);
                    ctx.lineTo(endX, this.y + offsetY + 10);
                    ctx.stroke();
                }

                // ìŠ¤í”¼ë“œ ë¼ì¸
                ctx.strokeStyle = 'rgba(170, 68, 255, 0.5)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                    const y = this.y - 20 + i * 10;
                    ctx.beginPath();
                    ctx.moveTo(this.x - this.direction * 30, y);
                    ctx.lineTo(this.x + this.direction * 20, y);
                    ctx.stroke();
                }
            }

            drawDoubleStab(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;
                const numHits = this.data.hits || 2;
                const colors = ['#aa44ff', '#cc66ff', '#ee88ff'];
                const gap = 0.75 / numHits;

                for (let i = 0; i < numHits; i++) {
                    const offset = i * gap;
                    const p = Math.max(0, Math.min(1, (progress - offset) / (1 - offset) * 1.8));

                    if (p > 0) {
                        const length = 60 * (1 - Math.abs(p - 0.5) * 2);
                        const yOff = (i - numHits * 0.3) * 10;
                        ctx.fillStyle = colors[i] || '#ee88ff';
                        ctx.beginPath();
                        ctx.moveTo(this.x + this.direction * 20, this.y - 5 + yOff);
                        ctx.lineTo(this.x + this.direction * (20 + length), this.y + yOff);
                        ctx.lineTo(this.x + this.direction * 20, this.y + 5 + yOff);
                        ctx.fill();

                        if (p > 0.4 && p < 0.6) {
                            ctx.fillStyle = '#ffffff';
                            ctx.beginPath();
                            ctx.arc(this.x + this.direction * 80, this.y + yOff, 10, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }

            drawAssassinate(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                // ê·¸ë¦¼ì ë¶„ì‹ 
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.7})`;
                for (let i = 0; i < 3; i++) {
                    const offsetX = this.direction * (i * 30 - progress * 60);
                    ctx.beginPath();
                    ctx.ellipse(this.x + offsetX, this.y, 25 - i * 5, 35 - i * 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ì¹˜ëª…ì  ì¼ê²©
                const strikeProgress = Math.max(0, progress - 0.3) / 0.7;
                if (strikeProgress > 0) {
                    // Xì ìŠ¬ë˜ì‹œ
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 5 - strikeProgress * 4;
                    ctx.lineCap = 'round';

                    const size = 40 + strikeProgress * 30;
                    const cx = this.x + this.direction * 60;

                    ctx.beginPath();
                    ctx.moveTo(cx - size, this.y - size);
                    ctx.lineTo(cx + size, this.y + size);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(cx + size, this.y - size);
                    ctx.lineTo(cx - size, this.y + size);
                    ctx.stroke();

                    // í•´ê³¨ ì´í™íŠ¸
                    if (strikeProgress > 0.5) {
                        ctx.font = `${30 + strikeProgress * 20}px Arial`;
                        ctx.fillStyle = `rgba(255, 0, 0, ${1 - strikeProgress})`;
                        ctx.textAlign = 'center';
                        ctx.fillText('ğŸ’€', cx, this.y + 10);
                    }
                }
            }

            drawArrowTrail(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                // í™”ì‚´ ê¶¤ì 
                ctx.strokeStyle = '#44ff66';
                ctx.lineWidth = 3 - progress * 2;
                ctx.lineCap = 'round';

                const length = 40;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + this.direction * length, this.y);
                ctx.stroke();

                // ë°”ëŒ íš¨ê³¼
                ctx.strokeStyle = 'rgba(200, 255, 200, 0.5)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    const offsetY = (i - 1) * 8;
                    ctx.beginPath();
                    ctx.moveTo(this.x - this.direction * 20, this.y + offsetY);
                    ctx.lineTo(this.x - this.direction * 50, this.y + offsetY);
                    ctx.stroke();
                }
            }

            drawDoubleShot(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                // ë‘ ê°œì˜ í™”ì‚´ ê¶¤ì 
                for (let i = 0; i < 2; i++) {
                    const offsetY = (i - 0.5) * 20;
                    const trailLength = 80 * (1 - progress);

                    // í™”ì‚´ ë¹› ê¶¤ì 
                    const gradient = ctx.createLinearGradient(
                        this.x, this.y + offsetY,
                        this.x + this.direction * trailLength, this.y + offsetY
                    );
                    gradient.addColorStop(0, 'rgba(68, 255, 102, 0)');
                    gradient.addColorStop(1, `rgba(68, 255, 102, ${alpha})`);

                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + offsetY);
                    ctx.lineTo(this.x + this.direction * trailLength, this.y + offsetY);
                    ctx.stroke();

                    // í™”ì‚´ì´‰
                    ctx.fillStyle = '#88ff88';
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.direction * trailLength, this.y + offsetY);
                    ctx.lineTo(this.x + this.direction * (trailLength - 15), this.y + offsetY - 5);
                    ctx.lineTo(this.x + this.direction * (trailLength - 15), this.y + offsetY + 5);
                    ctx.fill();
                }
            }

            drawArrowRain(progress) {
                const alpha = 1 - progress * 0.5;
                ctx.globalAlpha = alpha;

                // í•˜ëŠ˜ì—ì„œ ë‚´ë¦¬ëŠ” í™”ì‚´ë“¤
                const numArrows = 15;
                for (let i = 0; i < numArrows; i++) {
                    const delay = (i / numArrows) * 0.6;
                    const p = Math.max(0, (progress - delay) / (1 - delay));

                    if (p > 0 && p < 1) {
                        const x = this.data.startX + (i / numArrows) * this.data.width;
                        const startY = -50;
                        const endY = this.data.groundY || 480;
                        const y = startY + (endY - startY) * p;

                        // í™”ì‚´
                        ctx.fillStyle = '#44ff66';
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x - 4, y - 25);
                        ctx.lineTo(x + 4, y - 25);
                        ctx.fill();

                        // í™”ì‚´ ê¼¬ë¦¬
                        ctx.strokeStyle = 'rgba(68, 255, 102, 0.5)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x, y - 25);
                        ctx.lineTo(x, y - 60);
                        ctx.stroke();

                        // ì°©ì§€ ì´í™íŠ¸
                        if (p > 0.9) {
                            ctx.fillStyle = `rgba(68, 255, 102, ${(1 - p) * 5})`;
                            ctx.beginPath();
                            ctx.arc(x, endY, 20 * (p - 0.9) * 10, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }

            drawRageActivate(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                const radius = 10 + progress * 65;
                ctx.strokeStyle = '#ff4400';
                ctx.lineWidth = 7 - progress * 6;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.stroke();

                ctx.fillStyle = `rgba(255, 80, 0, ${alpha * 0.5})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius * 0.45, 0, Math.PI * 2);
                ctx.fill();

                for (let i = 0; i < 14; i++) {
                    const angle = (i / 14) * Math.PI * 2 + progress * 5;
                    const dist = 15 + progress * 55;
                    ctx.fillStyle = i % 2 === 0 ? '#ff6600' : '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(
                        this.x + Math.cos(angle) * dist,
                        this.y + Math.sin(angle) * dist,
                        5 - progress * 4, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }

            drawHasteActivate(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2 + progress * 3;
                    const startDist = 8 + progress * 15;
                    const endDist = 25 + progress * 55;

                    ctx.strokeStyle = `rgba(170, 68, 255, ${alpha * (1 - progress * 0.5)})`;
                    ctx.lineWidth = 3 - progress * 2;
                    ctx.beginPath();
                    ctx.moveTo(
                        this.x + Math.cos(angle) * startDist,
                        this.y + Math.sin(angle) * startDist
                    );
                    ctx.lineTo(
                        this.x + Math.cos(angle) * endDist,
                        this.y + Math.sin(angle) * endDist
                    );
                    ctx.stroke();
                }

                ctx.strokeStyle = `rgba(200, 160, 255, ${alpha * 0.6})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 20 + progress * 40, 0, Math.PI * 2);
                ctx.stroke();
            }

            drawSoulActivate(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                for (let i = 0; i < 3; i++) {
                    const delay = i * 0.22;
                    const p = Math.max(0, (progress - delay) / (1 - delay));
                    if (p > 0) {
                        const radius = 8 + p * 65;
                        ctx.strokeStyle = `rgba(68, 255, 200, ${alpha * (1 - p * 0.4)})`;
                        ctx.lineWidth = 4 - p * 3;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + progress * 4;
                    const dist = 12 + progress * 42;
                    ctx.fillStyle = `rgba(150, 255, 220, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(
                        this.x + Math.cos(angle) * dist,
                        this.y + Math.sin(angle) * dist,
                        3 - progress * 2.5, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }

            drawCritBurst(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha;

                // ë²ˆê°œ íš¨ê³¼
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const len = 30 + progress * 40;
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(
                        this.x + Math.cos(angle) * len + (Math.random() - 0.5) * 10,
                        this.y + Math.sin(angle) * len + (Math.random() - 0.5) * 10
                    );
                    ctx.stroke();
                }

                // ë³„ íš¨ê³¼
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 + progress * 4;
                    const dist = 20 + progress * 30;
                    this.drawStar(
                        this.x + Math.cos(angle) * dist,
                        this.y + Math.sin(angle) * dist,
                        5, 8, 4
                    );
                }
            }

            drawStar(x, y, arms, outerRadius, innerRadius) {
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                for (let i = 0; i < arms * 2; i++) {
                    const angle = (i * Math.PI) / arms;
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const px = x + Math.cos(angle - Math.PI / 2) * radius;
                    const py = y + Math.sin(angle - Math.PI / 2) * radius;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
            }

            drawLevelUpPillar(progress) {
                const alpha = 1 - progress;
                ctx.globalAlpha = alpha * 0.8;

                // ë¹› ê¸°ë‘¥
                const gradient = ctx.createLinearGradient(this.x, this.y + 60, this.x, this.y - 200);
                gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.6)');
                gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');

                ctx.fillStyle = gradient;
                ctx.fillRect(this.x - 30, this.y - 200, 60, 260);

                // ë°˜ì§ì´ëŠ” ë³„ íŒŒí‹°í´
                for (let i = 0; i < 12; i++) {
                    const yPos = this.y + 60 - (progress + (i / 12)) * 260;
                    const xOffset = Math.sin(yPos / 20 + i) * 25;
                    const size = 3 + Math.sin(Date.now() / 100 + i) * 2;

                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(this.x + xOffset, yPos, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // íˆ¬ì‚¬ì²´ í´ë˜ìŠ¤
        class Projectile {
            constructor(x, y, direction, damage, type = 'arrow', piercing = false, vy = 0) {
                this.x = x;
                this.y = y;
                this.direction = direction;
                this.speed = 14;
                this.damage = damage;
                this.type = type;
                this.piercing = piercing;
                this.hitMonsters = new Set();
                this.life = 100;
                this.trail = [];
                this.vy = vy;
            }

            update() {
                // ê¶¤ì  ì €ì¥
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 10) this.trail.shift();

                this.x += this.speed * this.direction;
                this.y += this.vy;
                this.life--;

                if (this.x < -50 || this.x > canvas.width + 50) return true;

                for (const monster of game.monsters) {
                    if (!monster.isDead && !this.hitMonsters.has(monster) &&
                        this.x > monster.x && this.x < monster.x + monster.width &&
                        this.y > monster.y && this.y < monster.y + monster.height) {
                        const isCrit = Math.random() * 100 < player.critChance;
                        monster.takeDamage(this.damage, isCrit);
                        this.hitMonsters.add(monster);

                        // íˆíŠ¸ ì´í™íŠ¸
                        createParticles(this.x, this.y, '#44ff66', 5);

                        if (!this.piercing) return true;
                    }
                }

                return this.life <= 0;
            }

            draw() {
                ctx.save();

                // ê¶¤ì  ê·¸ë¦¬ê¸°
                if (this.trail.length > 1) {
                    ctx.strokeStyle = player.buffs.soul ? 'rgba(0, 255, 255, 0.3)' : 'rgba(68, 255, 102, 0.3)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.stroke();
                }

                ctx.translate(this.x, this.y);
                if (this.direction === -1) ctx.scale(-1, 1);

                // í™”ì‚´ ë³¸ì²´
                const arrowColor = player.buffs.soul ? '#00ffff' : '#8B4513';

                // í™”ì‚´ëŒ€
                ctx.fillStyle = arrowColor;
                ctx.fillRect(-20, -2, 25, 4);

                // í™”ì‚´ì´‰
                ctx.fillStyle = '#aaaaaa';
                ctx.beginPath();
                ctx.moveTo(10, 0);
                ctx.lineTo(0, -5);
                ctx.lineTo(0, 5);
                ctx.fill();

                // ê¹ƒí„¸
                ctx.fillStyle = '#44ff66';
                ctx.beginPath();
                ctx.moveTo(-20, 0);
                ctx.lineTo(-28, -6);
                ctx.lineTo(-25, 0);
                ctx.lineTo(-28, 6);
                ctx.fill();

                // ì†Œìš¸ ì• ë¡œìš° ì´í™íŠ¸
                if (player.buffs.soul && player.buffs.soul.duration > 0) {
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 12, 0, Math.PI * 2);
                    ctx.fill();

                    // ë¹›ë‚˜ëŠ” ì…ì
                    for (let i = 0; i < 3; i++) {
                        const angle = Date.now() / 200 + i * Math.PI * 2 / 3;
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(Math.cos(angle) * 8, Math.sin(angle) * 8, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.restore();
            }
        }

        // ì½”ì¸(ë©”ì†Œ) í´ë˜ìŠ¤
        class Coin {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 6;
                this.vy = -Math.random() * 8 - 4;
                this.value = Math.floor(Math.random() * 10) + 5; // 5-14 ë©”ì†Œ
                this.life = 600; // 10ì´ˆ í›„ ì‚¬ë¼ì§
                this.bounces = 0;
                this.collected = false;
                this.collectFrame = 0;
            }

            update() {
                if (this.collected) {
                    // í”Œë ˆì´ì–´ì—ê²Œ ë¹¨ë ¤ë“¤ì–´ê°€ëŠ” íš¨ê³¼
                    const dx = player.x + player.width/2 - this.x;
                    const dy = player.y + player.height/2 - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 10) return true; // ìˆ˜ì§‘ ì™„ë£Œ

                    this.x += dx / dist * 8;
                    this.y += dy / dist * 8;
                    this.collectFrame++;
                    return false;
                }

                this.vy += game.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.life--;

                // ë°”ë‹¥ ì¶©ëŒ
                for (const p of game.platforms) {
                    if (this.y + 10 > p.y && this.y + 10 < p.y + p.height + 10 &&
                        this.x > p.x && this.x < p.x + p.width && this.vy > 0) {
                        this.y = p.y - 10;
                        this.vy *= -0.5; // ë°”ìš´ìŠ¤
                        this.vx *= 0.8;
                        this.bounces++;
                        if (this.bounces > 3) {
                            this.vy = 0;
                            this.vx = 0;
                        }
                    }
                }

                // í”Œë ˆì´ì–´ ê·¼ì²˜ë©´ ìë™ ìˆ˜ì§‘
                const dx = player.x + player.width/2 - this.x;
                const dy = player.y + player.height/2 - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 100) {
                    this.collected = true;
                    game.meso += this.value;
                }

                return this.life <= 0;
            }

            draw() {
                ctx.save();
                if (this.collected) {
                    ctx.globalAlpha = 1 - this.collectFrame / 20;
                } else if (this.life < 120) {
                    ctx.globalAlpha = (Math.sin(this.life / 10) + 1) / 2; // ê¹œë¹¡ì„
                }

                // ë©”ì†Œ ë™ì „
                ctx.fillStyle = '#ffcc00';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#ff9900';
                ctx.lineWidth = 2;
                ctx.stroke();

                // ë©”ì†Œ ê¸°í˜¸
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('M', this.x, this.y);

                ctx.restore();
            }
        }

        // ëª¬ìŠ¤í„° í´ë˜ìŠ¤
        class Monster {
            constructor(x, y, type = 'slime') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.spawnLevel = player.level; // ìƒì„± ì‹œì  í”Œë ˆì´ì–´ ë ˆë²¨ ì €ì¥

                const monsterTypes = {
                    slime: { width: 50, height: 40, hp: 30 + player.level * 10, damage: 8 + player.level * 2, exp: 25, color: '#44dd44' },
                    mushroom: { width: 55, height: 50, hp: 50 + player.level * 15, damage: 12 + player.level * 3, exp: 40, color: '#dd4444' },
                    stump: { width: 60, height: 55, hp: 80 + player.level * 20, damage: 15 + player.level * 4, exp: 60, color: '#8B4513' }
                };

                const mt = monsterTypes[type];
                Object.assign(this, mt);
                this.baseExp = this.exp; // ê¸°ë³¸ ê²½í—˜ì¹˜ ì €ì¥
                this.maxHp = this.hp;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = 0;
                this.isDead = false;
                this.deathTimer = 0;
                this.animFrame = 0;
                this.hitFlash = 0;
            }

            update() {
                if (this.isDead) {
                    this.deathTimer++;
                    return this.deathTimer > 30;
                }

                if (this.hitFlash > 0) this.hitFlash--;
                this.animFrame += 0.1;

                if (Math.random() < 0.02) this.vx = (Math.random() - 0.5) * 3;

                const dx = player.x - this.x;
                if (Math.abs(dx) < 300) this.vx += Math.sign(dx) * 0.1;
                this.vx = Math.max(-2, Math.min(2, this.vx));

                this.x += this.vx;
                this.vy += game.gravity;
                this.y += this.vy;

                for (const p of game.platforms) {
                    if (this.y + this.height > p.y && this.y + this.height < p.y + p.height + 10 &&
                        this.x + this.width > p.x && this.x < p.x + p.width && this.vy >= 0) {
                        this.y = p.y - this.height;
                        this.vy = 0;
                    }
                }

                if (this.x < 0) { this.x = 0; this.vx *= -1; }
                if (this.x + this.width > canvas.width) { this.x = canvas.width - this.width; this.vx *= -1; }

                if (player.invincible <= 0 && this.checkCollision(player)) {
                    player.hp -= this.damage;
                    player.invincible = 60;
                    player.vx = Math.sign(player.x - this.x) * 8;
                    player.vy = -5;
                    createDamageText(player.x, player.y, this.damage, '#ff4444');
                    updateUI();
                }

                return false;
            }

            checkCollision(obj) {
                return this.x < obj.x + obj.width && this.x + this.width > obj.x &&
                       this.y < obj.y + obj.height && this.y + this.height > obj.y;
            }

            draw() {
                ctx.save();
                if (this.isDead) ctx.globalAlpha = 1 - this.deathTimer / 30;
                if (this.hitFlash > 0) ctx.filter = 'brightness(2)';

                const bounce = Math.sin(this.animFrame) * 3;

                if (this.type === 'slime') {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.width/2, this.y + this.height - 15 + bounce, this.width/2 - 5, this.height/2 - 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.width/2 - 8, this.y + this.height - 25 + bounce, 8, 6, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'mushroom') {
                    ctx.fillStyle = '#DEB887';
                    ctx.fillRect(this.x + 18, this.y + 28 + bounce, 20, 22);
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.width/2, this.y + 22 + bounce, 28, 22, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(this.x + 18, this.y + 18 + bounce, 6, 0, Math.PI * 2);
                    ctx.arc(this.x + 38, this.y + 20 + bounce, 5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'stump') {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x + 10, this.y + 15 + bounce, 40, 40);
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.arc(this.x + 30, this.y + 35 + bounce, 12, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ëˆˆ
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(this.x + this.width/2 - 8, this.y + this.height/2 + bounce, 3, 0, Math.PI * 2);
                ctx.arc(this.x + this.width/2 + 8, this.y + this.height/2 + bounce, 3, 0, Math.PI * 2);
                ctx.fill();

                // HP ë°” (ë©”ì´í”ŒìŠ¤íƒ€ì¼)
                if (!this.isDead) {
                    // ëª¬ìŠ¤í„° ì´ë¦„
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    const names = { slime: 'ìŠ¬ë¼ì„', mushroom: 'ë¨¸ì‰¬ë£¸', stump: 'ìŠ¤í…€í”„' };
                    ctx.strokeText(names[this.type] || this.type, this.x + this.width/2, this.y - 18);
                    ctx.fillText(names[this.type] || this.type, this.x + this.width/2, this.y - 18);

                    // HP ë°” ë°°ê²½ (ê²€ì€ìƒ‰)
                    ctx.fillStyle = '#000';
                    ctx.fillRect(this.x - 2, this.y - 12, this.width + 4, 8);

                    // HP ë°” (ë¹¨ê°„ìƒ‰, ë¶€ë“œëŸ¬ìš´ íŠ¸ëœì§€ì…˜)
                    const hpPercent = this.hp / this.maxHp;
                    ctx.fillStyle = hpPercent > 0.5 ? '#ff4444' : hpPercent > 0.2 ? '#ff8844' : '#ffaa44';
                    ctx.fillRect(this.x, this.y - 10, hpPercent * this.width, 5);

                    // HP ë°” í…Œë‘ë¦¬
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(this.x - 2, this.y - 12, this.width + 4, 8);
                }

                ctx.restore();
            }

            takeDamage(dmg, isCrit = false, isBackstab = false) {
                let finalDmg = Math.floor(dmg * (isCrit ? 1.5 : 1) * (isBackstab ? 2 : 1));
                this.hp -= finalDmg;
                this.hitFlash = 10;

                // ì½¤ë³´ ì‹œìŠ¤í…œ
                const now = Date.now();
                if (now - game.lastHitTime < 1000) {
                    game.combo++;
                } else {
                    game.combo = 1;
                }
                game.lastHitTime = now;

                // í¬ë¦¬í‹°ì»¬ íƒ€ê²© ì‹œ í™”ë©´ í”ë“¤ë¦¼
                if (isCrit) {
                    const intensity = isBackstab ? 8 : 6;
                    game.screenShake = {
                        x: (Math.random() - 0.5) * intensity,
                        y: (Math.random() - 0.5) * intensity,
                        frames: 10
                    };
                    game.hitStop = 3;
                }

                const color = isBackstab ? '#ff00ff' : (isCrit ? '#ffaa00' : '#ffff00');
                createDamageText(this.x + this.width/2, this.y, finalDmg + (isCrit ? '!' : ''), color, isCrit, isBackstab);

                // í¬ë¦¬í‹°ì»¬ ì‹œ ë” ë§ì€ íŒŒí‹°í´
                const particleCount = isCrit ? 20 : 8;
                createParticles(this.x + this.width/2, this.y + this.height/2, this.color, particleCount, isCrit);

                if (this.hp <= 0) {
                    this.isDead = true;

                    // ë¹„ì„ í˜• EXP ìŠ¤ì¼€ì¼ë§: ë ˆë²¨ ì°¨ì´ì— ë”°ë¥¸ ë³´ìƒ ì¡°ì •
                    const levelDiff = player.level - this.spawnLevel;
                    let expMultiplier = 1 + (levelDiff * 0.15); // ë ˆë²¨ ì°¨ì´ë‹¹ Â±15%
                    expMultiplier = Math.max(0.3, Math.min(2.0, expMultiplier)); // ìµœì†Œ 30%, ìµœëŒ€ 200%
                    const finalExp = Math.floor(this.baseExp * expMultiplier);

                    player.exp += finalExp;
                    player.kills++;

                    // EXP í…ìŠ¤íŠ¸ í‘œì‹œ
                    createExpText(this.x + this.width/2, this.y, finalExp);

                    // ë©”ì†Œ ë“œë (1-3ê°œ)
                    const coinCount = Math.floor(Math.random() * 3) + 1;
                    for (let i = 0; i < coinCount; i++) {
                        game.coins.push(new Coin(this.x + this.width/2, this.y + this.height/2));
                    }

                    checkLevelUp();
                    updateUI();
                }
            }
        }

        // ì§ì—… ì„ íƒ
        function selectJob(jobId) {
            const job = JOBS[jobId];
            player.job = jobId;
            player.maxHp = job.baseHp;
            player.hp = job.baseHp;
            player.maxMp = job.baseMp;
            player.mp = job.baseMp;
            player.attack = job.baseAttack;
            player.speed = job.speed;
            player.jumpPower = job.jumpPower;
            player.critChance = job.critChance;

            document.getElementById('jobSelect').style.display = 'none';
            document.getElementById('gameUI').style.display = 'block';
            document.getElementById('controlsUI').style.display = 'block';
            document.getElementById('jobName').textContent = job.name;
            document.getElementById('jobIcon').textContent = job.icon;

            // ê²Œì„ ì‹œì‘ 3ì´ˆ í›„ ì»¨íŠ¸ë¡¤ ì„¤ëª… í˜ì´ë“œì•„ì›ƒ
            setTimeout(() => {
                document.getElementById('controlsUI').classList.add('fade-out');
            }, 3000);

            createSkillBar();
            updateUI();
            game.started = true;
        }

        function createSkillBar() {
            const skillBar = document.getElementById('skillBar');
            const job = JOBS[player.job];
            skillBar.innerHTML = '';

            // ê¸°ë³¸ ê³µê²© ìŠ¬ë¡¯
            const basicSlot = document.createElement('div');
            basicSlot.className = 'skill-slot ready';
            basicSlot.id = 'basicAttack';
            const basicIcons = { warrior: 'âš”', thief: 'ğŸ—¡', archer: 'ğŸ¹' };
            basicSlot.innerHTML = `<div class="key">A</div><div style="font-size: 20px">${basicIcons[player.job] || 'âš”'}</div><div style="font-size: 9px">ê¸°ë³¸</div>`;

            // Canvas ì˜¤ë²„ë ˆì´ ì¶”ê°€
            const basicCanvas = document.createElement('canvas');
            basicCanvas.className = 'cd-overlay';
            basicCanvas.width = 50;
            basicCanvas.height = 50;
            basicSlot.appendChild(basicCanvas);
            skillBar.appendChild(basicSlot);

            job.skills.forEach((skill, i) => {
                const slot = document.createElement('div');
                slot.className = 'skill-slot ready';
                slot.id = `skill${i}`;
                slot.innerHTML = `<div class="key">${skill.key}</div><div style="font-size: 20px">${skill.icon}</div><div style="font-size: 9px">${skill.name.substring(0, 4)}</div>`;

                // Canvas ì˜¤ë²„ë ˆì´ ì¶”ê°€
                const canvas = document.createElement('canvas');
                canvas.className = 'cd-overlay';
                canvas.width = 50;
                canvas.height = 50;
                slot.appendChild(canvas);
                skillBar.appendChild(slot);
            });
        }

        function updateSkillBar() {
            const job = JOBS[player.job];

            // ê¸°ë³¸ ê³µê²© ì¿¨ë‹¤ìš´
            const basicSlot = document.getElementById('basicAttack');
            const basicCanvas = basicSlot.querySelector('canvas.cd-overlay');
            if (player.attackCooldown > 0) {
                basicSlot.className = 'skill-slot';
                drawCooldownArc(basicCanvas, player.attackCooldown, job.basicAttack.cooldown);
            } else {
                basicSlot.className = 'skill-slot ready';
                if (basicCanvas) {
                    const ctx = basicCanvas.getContext('2d');
                    ctx.clearRect(0, 0, 50, 50);
                }
            }

            job.skills.forEach((skill, i) => {
                const slot = document.getElementById(`skill${i}`);
                const canvas = slot.querySelector('canvas.cd-overlay');
                const cooldown = player.skillCooldowns[i];
                if (cooldown > 0) {
                    slot.className = 'skill-slot';
                    let cdDiv = slot.querySelector('.cooldown');
                    if (!cdDiv) {
                        cdDiv = document.createElement('div');
                        cdDiv.className = 'cooldown';
                        slot.appendChild(cdDiv);
                    }
                    cdDiv.textContent = Math.ceil(cooldown / 60);

                    // ì›í˜• ì§„í–‰ë°” ê·¸ë¦¬ê¸°
                    drawCooldownArc(canvas, cooldown, skill.cooldown);
                } else {
                    slot.className = 'skill-slot ready';
                    const cdDiv = slot.querySelector('.cooldown');
                    if (cdDiv) cdDiv.remove();

                    // Canvas í´ë¦¬ì–´
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, 50, 50);
                    }
                }
            });
        }

        // ì›í˜• ì¿¨ë‹¤ìš´ ì§„í–‰ë°” ê·¸ë¦¬ê¸° (ë©”ì´í”ŒìŠ¤íƒ€ì¼)
        function drawCooldownArc(canvas, currentCd, maxCd) {
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const centerX = 25, centerY = 25, radius = 23;

            ctx.clearRect(0, 0, 50, 50);

            // ì¿¨ë‹¤ìš´ ë¹„ìœ¨ ê³„ì‚° (0 = ì™„ë£Œ, 1 = ì‹œì‘)
            const progress = currentCd / maxCd;

            // ë°˜íˆ¬ëª… ê²€ì€ìƒ‰ ì˜¤ë²„ë ˆì´ (ì›í˜•)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();

            // ì§„í–‰ë°” (ì‹œê³„ë°©í–¥, 12ì‹œ ë°©í–¥ë¶€í„°)
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * progress));
            ctx.stroke();
        }

        function updateBuffBar() {
            const buffBar = document.getElementById('buffBar');
            buffBar.innerHTML = '';
            for (const [buffName, buffData] of Object.entries(player.buffs)) {
                if (buffData.duration > 0) {
                    const buffIcon = document.createElement('div');
                    buffIcon.className = 'buff-icon';
                    const seconds = Math.ceil(buffData.duration / 60);

                    // ì•„ì´ì½˜ + ë‚¨ì€ ì‹œê°„ í…ìŠ¤íŠ¸
                    buffIcon.innerHTML = `
                        ${buffData.icon}
                        <div class="buff-time ${seconds <= 10 ? 'warning' : ''} ${seconds <= 3 ? 'critical' : ''}">${seconds}s</div>
                    `;
                    buffIcon.title = buffName;
                    buffBar.appendChild(buffIcon);
                }
            }
        }

        // ê¸°ë³¸ ê³µê²©
        function basicAttack() {
            if (!game.started || player.attackCooldown > 0) return;

            const job = JOBS[player.job];
            const basic = job.basicAttack;
            const attackMultiplier = player.buffs.rage ? player.buffs.rage.attackBonus : 1;
            const damage = player.attack * basic.damage * attackMultiplier;

            player.isAttacking = true;
            player.attackCooldown = basic.cooldown || 20;
            setTimeout(() => player.isAttacking = false, basic.animDuration || 150);

            if (basic.type === 'sword') {
                // ì „ì‚¬ ê¸°ë³¸ ê³µê²© - ê²€ íœ˜ë‘ë¥´ê¸°
                game.effects.push(new Effect('swordSlash', player.x + player.width/2, player.y + player.height/2, player.direction, { maxFrames: 15 }));

                const attackBox = {
                    x: player.direction === 1 ? player.x + player.width : player.x - basic.range,
                    y: player.y - 10,
                    width: basic.range,
                    height: player.height + 20
                };

                for (const monster of game.monsters) {
                    if (!monster.isDead && attackBox.x < monster.x + monster.width && attackBox.x + attackBox.width > monster.x &&
                        attackBox.y < monster.y + monster.height && attackBox.y + attackBox.height > monster.y) {
                        monster.takeDamage(damage, Math.random() * 100 < player.critChance);
                        monster.vx = player.direction * 8;
                        monster.vy = -4;
                    }
                }
            } else if (basic.type === 'dagger') {
                // ë„ì  ê¸°ë³¸ ê³µê²© - ë¹ ë¥¸ ë‹¨ê²€
                game.effects.push(new Effect('daggerSlash', player.x + player.width/2, player.y + player.height/2, player.direction, { maxFrames: 12 }));

                const attackBox = {
                    x: player.direction === 1 ? player.x + player.width : player.x - basic.range,
                    y: player.y - 5,
                    width: basic.range,
                    height: player.height + 10
                };

                for (let h = 0; h < basic.hits; h++) {
                    setTimeout(() => {
                        for (const monster of game.monsters) {
                            if (!monster.isDead && attackBox.x < monster.x + monster.width && attackBox.x + attackBox.width > monster.x &&
                                attackBox.y < monster.y + monster.height && attackBox.y + attackBox.height > monster.y) {
                                monster.takeDamage(damage, Math.random() * 100 < player.critChance);
                            }
                        }
                    }, h * 80);
                }
            } else if (basic.type === 'arrow') {
                // ê¶ìˆ˜ ê¸°ë³¸ ê³µê²© - í™”ì‚´ ë°œì‚¬
                game.effects.push(new Effect('arrowTrail', player.x + player.width/2, player.y + player.height/2, player.direction, { maxFrames: 10 }));

                const piercing = player.buffs.soul && player.buffs.soul.duration > 0;
                game.projectiles.push(new Projectile(
                    player.x + (player.direction === 1 ? player.width : 0),
                    player.y + player.height/2,
                    player.direction,
                    damage,
                    'arrow',
                    piercing
                ));
            }
        }

        // ìŠ¤í‚¬ ì‚¬ìš©
        function useSkill(skillIndex) {
            if (!game.started || player.skillCooldowns[skillIndex] > 0) return;

            const job = JOBS[player.job];
            const skill = job.skills[skillIndex];
            const slot = document.getElementById(`skill${skillIndex}`);

            // MP ë¶€ì¡± ì‹œ í”ë“¤ë¦¼ ì• ë‹ˆë©”ì´ì…˜
            if (player.mp < skill.mp) {
                if (slot) {
                    slot.classList.add('shake');
                    setTimeout(() => slot.classList.remove('shake'), 300);
                }
                return;
            }

            // ìŠ¤í‚¬ ì‚¬ìš© ì‹œ ëˆŒë¦¼ ì• ë‹ˆë©”ì´ì…˜
            if (slot) {
                slot.classList.add('press');
                setTimeout(() => slot.classList.remove('press'), 200);
            }

            player.mp -= skill.mp;
            player.skillCooldowns[skillIndex] = skill.cooldown;
            player.isAttacking = true;
            setTimeout(() => player.isAttacking = false, 200);

            // ìŠ¤í‚¬ëª… í‘œì‹œ
            createSkillNameText(skill.name);

            const attackMultiplier = player.buffs.rage ? player.buffs.rage.attackBonus : 1;
            const baseDamage = player.attack * skill.damage * attackMultiplier;

            switch (skill.type) {
                case 'powerStrike':
                    performPowerStrike(baseDamage);
                    break;
                case 'slashBlast':
                    performSlashBlast(baseDamage, skill.range);
                    break;
                case 'doubleStab':
                    performDoubleStab(baseDamage, skill.hits);
                    break;
                case 'assassinate':
                    performAssassinate(baseDamage, skill.backstab);
                    break;
                case 'doubleShot':
                    performDoubleShot(baseDamage, skill.arrows, skill.spread);
                    break;
                case 'arrowRain':
                    performArrowRain(baseDamage);
                    break;
            }

            if (skill.buff) {
                player.buffs[skill.buff] = { duration: skill.duration, icon: skill.icon, ...skill };
                const buffEffects = { rage: 'rageActivate', haste: 'hasteActivate', soul: 'soulActivate' };
                if (buffEffects[skill.buff]) {
                    game.effects.push(new Effect(buffEffects[skill.buff], player.x + player.width/2, player.y + player.height/2, player.direction, { maxFrames: 40 }));
                }
            }

            updateUI();
        }

        function performPowerStrike(damage) {
            game.effects.push(new Effect('powerStrike', player.x + player.width/2, player.y + player.height/2, player.direction, { maxFrames: 25 }));

            const attackBox = {
                x: player.direction === 1 ? player.x + player.width - 20 : player.x - 80,
                y: player.y - 20,
                width: 100,
                height: player.height + 40
            };

            for (const monster of game.monsters) {
                if (!monster.isDead && attackBox.x < monster.x + monster.width && attackBox.x + attackBox.width > monster.x &&
                    attackBox.y < monster.y + monster.height && attackBox.y + attackBox.height > monster.y) {
                    monster.takeDamage(damage, Math.random() * 100 < player.critChance);
                    monster.vx = player.direction * 15;
                    monster.vy = -8;
                }
            }
        }

        function performSlashBlast(damage, range) {
            game.effects.push(new Effect('slashBlast', player.x + player.width/2, player.y + player.height/2, player.direction, { maxFrames: 30 }));

            for (const monster of game.monsters) {
                if (!monster.isDead) {
                    const dx = monster.x + monster.width/2 - (player.x + player.width/2);
                    const dy = monster.y + monster.height/2 - (player.y + player.height/2);
                    if (Math.sqrt(dx*dx + dy*dy) < range) {
                        monster.takeDamage(damage, Math.random() * 100 < player.critChance);
                    }
                }
            }
        }

        function performDoubleStab(damage, hits) {
            game.effects.push(new Effect('doubleStab', player.x + player.width/2, player.y + player.height/2, player.direction, { maxFrames: 25, hits: hits }));

            const attackBox = {
                x: player.direction === 1 ? player.x + player.width : player.x - 80,
                y: player.y - 10,
                width: 80,
                height: player.height + 20
            };

            for (let h = 0; h < hits; h++) {
                setTimeout(() => {
                    for (const monster of game.monsters) {
                        if (!monster.isDead && attackBox.x < monster.x + monster.width && attackBox.x + attackBox.width > monster.x &&
                            attackBox.y < monster.y + monster.height && attackBox.y + attackBox.height > monster.y) {
                            monster.takeDamage(damage, Math.random() * 100 < player.critChance);
                        }
                    }
                }, h * 100);
            }
        }

        function performAssassinate(damage, backstab) {
            game.effects.push(new Effect('assassinate', player.x + player.width/2, player.y + player.height/2, player.direction, { maxFrames: 30 }));

            const attackBox = {
                x: player.direction === 1 ? player.x + player.width : player.x - 100,
                y: player.y - 10,
                width: 100,
                height: player.height + 20
            };

            setTimeout(() => {
                for (const monster of game.monsters) {
                    if (!monster.isDead && attackBox.x < monster.x + monster.width && attackBox.x + attackBox.width > monster.x &&
                        attackBox.y < monster.y + monster.height && attackBox.y + attackBox.height > monster.y) {
                        monster.takeDamage(damage, Math.random() * 100 < player.critChance, backstab);
                    }
                }
            }, 200);
        }

        function performDoubleShot(damage, arrows, spread) {
            game.effects.push(new Effect('doubleShot', player.x + player.width/2, player.y + player.height/2, player.direction, { maxFrames: 15 }));

            const piercing = player.buffs.soul && player.buffs.soul.duration > 0;
            for (let i = 0; i < arrows; i++) {
                setTimeout(() => {
                    const offsetY = (i - (arrows-1)/2) * 15;
                    const vy = spread ? (i - (arrows-1)/2) * 3 : 0;
                    game.projectiles.push(new Projectile(
                        player.x + (player.direction === 1 ? player.width : 0),
                        player.y + player.height/2 + offsetY,
                        player.direction, damage, 'arrow', piercing, vy
                    ));
                }, i * 80);
            }
        }

        function performArrowRain(damage) {
            const startX = Math.max(0, player.x - 200);
            const width = 400;

            game.effects.push(new Effect('arrowRain', player.x, player.y, player.direction, {
                maxFrames: 60,
                startX: startX,
                width: width,
                groundY: 480
            }));

            // ì‹œê°„ì°¨ ë°ë¯¸ì§€
            for (let i = 0; i < 15; i++) {
                const delay = (i / 15) * 600 + 300;
                const x = startX + (i / 15) * width;
                setTimeout(() => {
                    for (const monster of game.monsters) {
                        if (!monster.isDead && Math.abs(monster.x + monster.width/2 - x) < 40) {
                            monster.takeDamage(damage, Math.random() * 100 < player.critChance);
                        }
                    }
                }, delay);
            }
        }

        function createParticles(x, y, color, count = 10, isCrit = false) {
            for (let i = 0; i < count; i++) {
                game.particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8 - 3,
                    life: 30,
                    color,
                    size: Math.random() * 5 + 2,
                    isStar: isCrit && Math.random() > 0.5
                });
            }

            // í¬ë¦¬í‹°ì»¬ ë²„ìŠ¤íŠ¸ ì´í™íŠ¸
            if (isCrit) {
                game.effects.push(new Effect('critBurst', x, y, 1, { maxFrames: 15 }));
            }
        }

        function createDamageText(x, y, damage, color, isCrit = false, isBackstab = false) {
            // ì¢Œìš° ë¶„ì‚° ë°°ì¹˜ (ì—¬ëŸ¬ ëŒ€ë¯¸ì§€ ë™ì‹œ ë°œìƒ ì‹œ ê²¹ì¹˜ì§€ ì•Šê²Œ)
            const offsetX = (Math.random() - 0.5) * 30;
            game.damageTexts.push({ x: x + offsetX, y, damage, color, life: 60, vy: -2, isCrit, isBackstab });
        }

        function createExpText(x, y, exp) {
            game.damageTexts.push({
                x, y,
                damage: `+${exp} EXP`,
                color: '#ffff00',
                life: 90,
                vy: -1.5,
                isExp: true
            });
        }

        function createSkillNameText(skillName) {
            const job = JOBS[player.job];
            game.skillNames.push({
                x: player.x + player.width/2,
                y: player.y - 20,
                name: skillName,
                color: job.color,
                life: 60,
                vy: -1
            });
        }

        function createHealText(amount, type) {
            const color = type === 'hp' ? '#44ff44' : '#4444ff';
            const text = type === 'hp' ? `+${amount} HP` : `+${amount} MP`;
            game.damageTexts.push({
                x: player.x + player.width/2,
                y: player.y,
                damage: text,
                color,
                life: 60,
                vy: -2,
                isHeal: true
            });
        }

        function checkLevelUp() {
            while (player.exp >= player.expToLevel) {
                player.exp -= player.expToLevel;
                player.level++;

                const job = JOBS[player.job];
                const hpGain = job.hpPerLevel;
                const mpGain = job.mpPerLevel;

                player.maxHp += hpGain;
                player.hp = player.maxHp;
                player.maxMp += mpGain;
                player.mp = player.maxMp;
                player.attack += job.attackPerLevel;
                player.critChance += 0.5; // ë ˆë²¨ë‹¹ í¬ë¦¬í‹°ì»¬ í™•ë¥  +0.5%
                player.expToLevel = Math.floor(player.expToLevel * 1.5);

                // íšŒë³µ í…ìŠ¤íŠ¸ í‘œì‹œ
                createHealText(hpGain, 'hp');
                setTimeout(() => createHealText(mpGain, 'mp'), 150);

                // ë ˆë²¨ì—… ë¹›ê¸°ë‘¥
                game.effects.push(new Effect('levelUpPillar', player.x + player.width/2, player.y, 1, { maxFrames: 180 }));

                // ë ˆë²¨ì—… í…ìŠ¤íŠ¸ (ë ˆë²¨ ìˆ«ì í¬í•¨)
                const levelUpText = document.getElementById('levelUpText');
                levelUpText.textContent = `LEVEL UP! Lv.${player.level}`;
                levelUpText.style.display = 'block';
                levelUpText.style.animation = 'none';
                levelUpText.offsetHeight;
                levelUpText.style.animation = 'levelUp 2s ease-out forwards';
                setTimeout(() => levelUpText.style.display = 'none', 2000);

                // ìŠ¤íƒ¯ ì¦ê°€ë¶„ í‘œì‹œ
                const statGainText = document.getElementById('statGainText');
                statGainText.textContent = `HP +${hpGain} | MP +${mpGain} | ATK +${job.attackPerLevel} | CRIT +0.5%`;
                statGainText.style.display = 'block';
                statGainText.style.animation = 'none';
                statGainText.offsetHeight;
                statGainText.style.animation = 'levelUp 1.5s ease-out forwards';
                setTimeout(() => statGainText.style.display = 'none', 1500);

                for (let i = 0; i < 50; i++) {
                    game.particles.push({
                        x: player.x + player.width/2 + (Math.random() - 0.5) * 100,
                        y: player.y + player.height/2 + (Math.random() - 0.5) * 100,
                        vx: (Math.random() - 0.5) * 4,
                        vy: -Math.random() * 5,
                        life: 60,
                        color: '#ffff00',
                        size: Math.random() * 6 + 3
                    });
                }
            }
        }

        function updateUI() {
            if (!game.started) return;
            document.getElementById('level').textContent = player.level;

            // HP ë°” ì—…ë°ì´íŠ¸ ë° ìœ„í—˜ êµ¬ê°„(â‰¤30%) ê¹œë¹¡ íš¨ê³¼
            const hpBar = document.getElementById('hpBar');
            const hpPercent = player.hp / player.maxHp * 100;
            hpBar.style.width = hpPercent + '%';
            if (hpPercent <= 30) {
                hpBar.classList.add('hp-fill-danger');
            } else {
                hpBar.classList.remove('hp-fill-danger');
            }

            document.getElementById('hpText').textContent = `${Math.max(0, Math.floor(player.hp))}/${player.maxHp}`;
            document.getElementById('mpBar').style.width = (player.mp / player.maxMp * 100) + '%';
            document.getElementById('mpText').textContent = `${Math.max(0, Math.floor(player.mp))}/${player.maxMp}`;
            document.getElementById('expBar').style.width = (player.exp / player.expToLevel * 100) + '%';
            document.getElementById('expText').textContent = `${player.exp}/${player.expToLevel}`;
            document.getElementById('attack').textContent = Math.floor(player.attack * (player.buffs.rage ? player.buffs.rage.attackBonus : 1));
            document.getElementById('crit').textContent = player.critChance;
            document.getElementById('kills').textContent = player.kills;
        }

        function spawnMonster() {
            const now = Date.now();
            if (now - game.lastMonsterSpawn > game.monsterSpawnInterval && game.monsters.length < 10) {
                const x = Math.random() * (canvas.width - 100) + 50;
                const rand = Math.random();
                let type = 'slime';
                if (rand > 0.7 && player.level >= 3) type = 'stump';
                else if (rand > 0.4) type = 'mushroom';
                game.monsters.push(new Monster(x, 50, type));
                game.lastMonsterSpawn = now;
                game.monsterSpawnInterval = Math.max(1000, 2500 - player.level * 100);
            }
        }

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a1a3e');
            gradient.addColorStop(0.5, '#2a2a5e');
            gradient.addColorStop(1, '#3a3a7e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 50; i++) {
                const x = (i * 73) % canvas.width;
                const y = (i * 37) % (canvas.height - 200);
                ctx.globalAlpha = 0.3 + Math.sin(Date.now() / 1000 + i) * 0.3;
                ctx.beginPath();
                ctx.arc(x, y, (i % 3) + 1, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            for (const p of game.platforms) {
                const platGradient = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.height);
                platGradient.addColorStop(0, '#5a8a5a');
                platGradient.addColorStop(1, '#3a6a3a');
                ctx.fillStyle = platGradient;
                ctx.fillRect(p.x, p.y, p.width, p.height);
                ctx.fillStyle = '#7aba7a';
                ctx.fillRect(p.x, p.y, p.width, 5);
                ctx.fillStyle = '#4a9a4a';
                for (let i = 0; i < p.width; i += 10) {
                    ctx.beginPath();
                    ctx.moveTo(p.x + i, p.y);
                    ctx.lineTo(p.x + i + 5, p.y - 8);
                    ctx.lineTo(p.x + i + 10, p.y);
                    ctx.fill();
                }
            }
        }

        function drawMinimap() {
            const mapX = canvas.width - 160;
            const mapY = 10;
            const mapW = 150;
            const mapH = 100;
            const scale = 1 / 6.67;

            ctx.save();

            // ë°°ê²½
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(mapX, mapY, mapW, mapH);
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.strokeRect(mapX, mapY, mapW, mapH);

            // í”Œë«í¼
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            for (const p of game.platforms) {
                const x = mapX + p.x * scale;
                const y = mapY + p.y * scale;
                const w = p.width * scale;
                const h = p.height * scale;
                ctx.strokeRect(x, y, w, h);
            }

            // ëª¬ìŠ¤í„° (ë¹¨ê°„ ì )
            ctx.fillStyle = '#ff4444';
            for (const m of game.monsters) {
                if (!m.isDead) {
                    ctx.beginPath();
                    ctx.arc(mapX + (m.x + m.width/2) * scale, mapY + (m.y + m.height/2) * scale, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // í”Œë ˆì´ì–´ (íŒŒë€ ì )
            ctx.fillStyle = '#4444ff';
            ctx.beginPath();
            ctx.arc(mapX + (player.x + player.width/2) * scale, mapY + (player.y + player.height/2) * scale, 3, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawPlayer() {
            const px = player.x, py = player.y, dir = player.direction;
            const job = JOBS[player.job];

            // ê·¸ë¦¼ì (ì í”„ ë†’ì´ì— ë°˜ë¹„ë¡€)
            const groundY = 500;
            const jumpHeight = Math.max(0, groundY - (py + player.height));
            const shadowSize = Math.max(15, 30 - jumpHeight / 10);
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(px + player.width/2, groundY, shadowSize, shadowSize/2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // ì”ìƒ íš¨ê³¼ (í—¤ì´ìŠ¤íŠ¸ ë²„í”„ ì‹œ)
            if (player.buffs.haste && player.buffs.haste.duration > 0 && player.trail.length > 0) {
                for (let i = 0; i < player.trail.length; i++) {
                    const t = player.trail[i];
                    ctx.save();
                    ctx.globalAlpha = 0.2 * (i / player.trail.length);
                    ctx.fillStyle = job.color;
                    ctx.fillRect(t.x + 8, t.y + 20, 24, 30);
                    ctx.restore();
                }
            }

            ctx.save();
            if (player.invincible > 0 && Math.floor(player.invincible / 5) % 2 === 0) ctx.globalAlpha = 0.5;

            ctx.translate(px + player.width/2, py);
            ctx.scale(dir, 1);
            ctx.translate(-(px + player.width/2), -py);

            // ë²„í”„ ì´í™íŠ¸
            if (player.buffs.rage && player.buffs.rage.duration > 0) {
                ctx.fillStyle = 'rgba(255, 100, 50, 0.3)';
                ctx.beginPath();
                ctx.arc(px + player.width/2, py + player.height/2, 40 + Math.sin(Date.now()/100) * 5, 0, Math.PI * 2);
                ctx.fill();
            }
            if (player.buffs.haste && player.buffs.haste.duration > 0) {
                ctx.fillStyle = 'rgba(170, 68, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(px + player.width/2, py + player.height/2, 35, 0, Math.PI * 2);
                ctx.fill();
            }
            if (player.buffs.soul && player.buffs.soul.duration > 0) {
                ctx.fillStyle = 'rgba(68, 255, 102, 0.3)';
                ctx.beginPath();
                ctx.arc(px + player.width/2, py + player.height/2, 35, 0, Math.PI * 2);
                ctx.fill();
            }

            const bodyColor = job ? job.color : '#4488ff';

            // ëª¸í†µ
            ctx.fillStyle = bodyColor;
            ctx.fillRect(px + 8, py + 20, 24, 30);

            // ë¨¸ë¦¬
            ctx.fillStyle = '#ffcc99';
            ctx.beginPath();
            ctx.arc(px + player.width/2, py + 15, 15, 0, Math.PI * 2);
            ctx.fill();

            // ì§ì—…ë³„ í—¤ì–´/ëª¨ì
            if (player.job === 'warrior') {
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(px + player.width/2, py + 8, 14, Math.PI, Math.PI * 2);
                ctx.fill();
            } else if (player.job === 'thief') {
                ctx.fillStyle = '#442266';
                ctx.beginPath();
                ctx.moveTo(px + 5, py + 15);
                ctx.lineTo(px + 20, py - 5);
                ctx.lineTo(px + 35, py + 15);
                ctx.fill();
            } else if (player.job === 'archer') {
                ctx.fillStyle = '#228844';
                ctx.beginPath();
                ctx.arc(px + player.width/2, py + 10, 13, Math.PI, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#116633';
                ctx.beginPath();
                ctx.moveTo(px + 10, py + 5);
                ctx.lineTo(px + 20, py - 10);
                ctx.lineTo(px + 30, py + 5);
                ctx.fill();
            }

            // ëˆˆ
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(px + player.width/2 + 5, py + 15, 2, 0, Math.PI * 2);
            ctx.fill();

            // ë‹¤ë¦¬
            ctx.fillStyle = '#333';
            ctx.fillRect(px + 10, py + 50, 8, 10);
            ctx.fillRect(px + 22, py + 50, 8, 10);

            // ë¬´ê¸°
            if (player.job === 'warrior') {
                ctx.fillStyle = '#888';
                ctx.fillRect(px + 35, py + 25, 8, 35);
                ctx.fillStyle = '#ffcc00';
                ctx.fillRect(px + 33, py + 22, 12, 8);
            } else if (player.job === 'thief') {
                ctx.fillStyle = '#666';
                ctx.beginPath();
                ctx.moveTo(px + 40, py + 30);
                ctx.lineTo(px + 55, py + 25);
                ctx.lineTo(px + 55, py + 35);
                ctx.fill();
            } else if (player.job === 'archer') {
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(px + 35, py + 30, 20, -Math.PI/2, Math.PI/2);
                ctx.stroke();
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(px + 35, py + 10);
                ctx.lineTo(px + 35, py + 50);
                ctx.stroke();
            }

            ctx.restore();
        }

        function gameLoop() {
            if (!game.started) {
                requestAnimationFrame(gameLoop);
                return;
            }

            // íˆíŠ¸ìŠ¤í†± (í¬ë¦¬í‹°ì»¬ íƒ€ê²© ì‹œ í”„ë ˆì„ ì •ì§€)
            if (game.hitStop > 0) {
                game.hitStop--;
                drawBackground();
                drawPlayer();
                for (const m of game.monsters) m.draw();
                for (const e of game.effects) e.draw();
                for (const p of game.projectiles) p.draw();
                for (const c of game.coins) c.draw();
                requestAnimationFrame(gameLoop);
                return;
            }

            // ì½¤ë³´ ë¦¬ì…‹ ì²´í¬
            if (game.combo > 0 && Date.now() - game.lastHitTime > 1000) {
                game.combo = 0;
            }

            // í™”ë©´ í”ë“¤ë¦¼ ê°ì†Œ
            if (game.screenShake.frames > 0) {
                game.screenShake.frames--;
                if (game.screenShake.frames === 0) {
                    game.screenShake.x = 0;
                    game.screenShake.y = 0;
                }
            }

            // í”Œë ˆì´ì–´ ì”ìƒ ì—…ë°ì´íŠ¸ (í—¤ì´ìŠ¤íŠ¸ ë²„í”„ ì‹œ)
            if (player.buffs.haste && player.buffs.haste.duration > 0) {
                player.trail.push({ x: player.x, y: player.y });
                if (player.trail.length > 3) player.trail.shift();
            } else {
                player.trail = [];
            }

            // MP ìë™ íšŒë³µ
            if (player.mp < player.maxMp) player.mp += 0.05;

            // ì¿¨ë‹¤ìš´
            if (player.attackCooldown > 0) player.attackCooldown--;
            for (let i = 0; i < player.skillCooldowns.length; i++) {
                if (player.skillCooldowns[i] > 0) player.skillCooldowns[i]--;
            }

            // ë²„í”„ ì—…ë°ì´íŠ¸
            for (const [buffName, buffData] of Object.entries(player.buffs)) {
                if (buffData.duration > 0) {
                    buffData.duration--;
                    if (buffData.duration <= 0) delete player.buffs[buffName];
                }
            }
            updateBuffBar();
            updateSkillBar();

            // ì´ë™
            let currentSpeed = player.speed * (player.buffs.haste ? player.buffs.haste.speedBonus : 1);
            if (game.keys['ArrowLeft']) {
                player.vx = -currentSpeed;
                player.direction = -1;
            } else if (game.keys['ArrowRight'] || game.keys['KeyD']) {
                player.vx = currentSpeed;
                player.direction = 1;
            } else {
                player.vx *= 0.8;
            }

            if ((game.keys['ArrowUp'] || game.keys['Space'] || game.keys['KeyW']) && !player.isJumping) {
                player.vy = player.jumpPower;
                player.isJumping = true;
            }

            player.x += player.vx;
            player.vy += game.gravity;
            player.y += player.vy;

            // í”Œë«í¼ ì¶©ëŒ
            player.isJumping = true;
            for (const p of game.platforms) {
                if (player.y + player.height > p.y && player.y + player.height < p.y + p.height + 10 &&
                    player.x + player.width > p.x && player.x < p.x + p.width && player.vy >= 0) {
                    player.y = p.y - player.height;
                    player.vy = 0;
                    player.isJumping = false;
                }
            }

            // ê²½ê³„
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            if (player.y > canvas.height) {
                player.y = 100;
                player.hp -= 20;
                updateUI();
            }

            if (player.invincible > 0) player.invincible--;

            // ì—…ë°ì´íŠ¸
            spawnMonster();
            game.monsters = game.monsters.filter(m => !m.update());
            game.projectiles = game.projectiles.filter(p => !p.update());
            game.effects = game.effects.filter(e => !e.update());
            game.coins = game.coins.filter(c => !c.update());

            game.particles = game.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life--;
                return p.life > 0;
            });

            game.damageTexts = game.damageTexts.filter(t => {
                t.y += t.vy;
                t.life--;
                return t.life > 0;
            });

            game.skillNames = game.skillNames.filter(s => {
                s.y += s.vy;
                s.life--;
                return s.life > 0;
            });

            // ì‚¬ë§
            if (player.hp <= 0) {
                player.hp = player.maxHp;
                player.mp = player.maxMp;
                player.x = 100;
                player.y = 400;
                player.exp = Math.floor(player.exp / 2);
                updateUI();
            }

            // ë Œë”ë§
            ctx.save();

            // í™”ë©´ í”ë“¤ë¦¼ ì ìš©
            if (game.screenShake.frames > 0) {
                ctx.translate(game.screenShake.x, game.screenShake.y);
            }

            drawBackground();
            for (const monster of game.monsters) monster.draw();
            for (const coin of game.coins) coin.draw();
            drawPlayer();
            for (const proj of game.projectiles) proj.draw();
            for (const effect of game.effects) effect.draw();

            ctx.restore();

            // íŒŒí‹°í´
            for (const p of game.particles) {
                ctx.globalAlpha = p.life / 30;
                ctx.fillStyle = p.color;

                if (p.isStar) {
                    // ë³„ ëª¨ì–‘ íŒŒí‹°í´
                    ctx.beginPath();
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI) / 4;
                        const radius = i % 2 === 0 ? p.size : p.size/2;
                        const px = p.x + Math.cos(angle - Math.PI / 2) * radius;
                        const py = p.y + Math.sin(angle - Math.PI / 2) * radius;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;

            // ë°ë¯¸ì§€ í…ìŠ¤íŠ¸
            for (const t of game.damageTexts) {
                ctx.globalAlpha = t.life / 60;
                ctx.fillStyle = t.color;

                // í¬ë¦¬í‹°ì»¬: í°íŠ¸ í¬ê¸° 1.5ë°°, ë°±ìŠ¤íƒ­: ë³¼ë“œì²´ ê°•í™”, EXP: í¬ê²Œ, íšŒë³µ: ì¤‘ê°„
                let fontSize = 20;
                let fontWeight = 'bold';
                if (t.isCrit) fontSize = 30;
                if (t.isBackstab) fontWeight = '900';
                if (t.isExp) fontSize = 24;
                if (t.isHeal) fontSize = 22;

                ctx.font = `${fontWeight} ${fontSize}px Arial`;
                ctx.textAlign = 'center';

                // ì™¸ê³½ì„  (ë©”ì´í”ŒìŠ¤íƒ€ì¼)
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(t.damage, t.x, t.y);

                // í…ìŠ¤íŠ¸
                ctx.fillText(t.damage, t.x, t.y);
            }
            ctx.globalAlpha = 1;

            // ìŠ¤í‚¬ëª… í…ìŠ¤íŠ¸
            for (const s of game.skillNames) {
                ctx.globalAlpha = s.life / 60;
                ctx.fillStyle = s.color;
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';

                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(s.name, s.x, s.y);
                ctx.fillText(s.name, s.x, s.y);
            }
            ctx.globalAlpha = 1;

            // ì½¤ë³´ ì¹´ìš´í„° (ìš°ìƒë‹¨)
            if (game.combo > 0) {
                const comboColor = game.combo >= 30 ? '#ff4444' : (game.combo >= 10 ? '#ffaa00' : '#ffffff');
                const comboScale = 1 + Math.sin(Date.now() / 100) * 0.1;

                ctx.save();
                ctx.translate(canvas.width - 80, 40);
                ctx.scale(comboScale, comboScale);
                ctx.translate(-canvas.width + 80, -40);

                ctx.fillStyle = comboColor;
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'right';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(`${game.combo} COMBO!`, canvas.width - 20, 40);
                ctx.fillText(`${game.combo} COMBO!`, canvas.width - 20, 40);
                ctx.restore();
            }

            // ë©”ì†Œ ì¹´ìš´í„° (ìš°ìƒë‹¨, ì½¤ë³´ ì•„ë˜)
            ctx.fillStyle = '#ffcc00';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'right';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeText(`ğŸ’° ë©”ì†Œ: ${game.meso}`, canvas.width - 20, 70);
            ctx.fillText(`ğŸ’° ë©”ì†Œ: ${game.meso}`, canvas.width - 20, 70);

            // ë¯¸ë‹ˆë§µ
            drawMinimap();

            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (e) => {
            game.keys[e.code] = true;
            if (e.code === 'KeyA' && !e.repeat) basicAttack();
            if (e.code === 'KeyZ') useSkill(0);
            if (e.code === 'KeyX') useSkill(1);
            if (e.code === 'KeyC') useSkill(2);
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
        });

        document.addEventListener('keyup', (e) => {
            game.keys[e.code] = false;
        });

        gameLoop();
    </script>
</body>
</html>
